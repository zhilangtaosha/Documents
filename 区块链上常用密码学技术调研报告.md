# 区块链中常用密码学技术报告

密码学技术在区块链中发挥着极其关键的作用，区块链技术的迅速发展也使得密码学从幕后走到台前。本报告调研了目前主流的区块链项目和发表在安全和密码领域重要学术会议上的区块链论文，按照**实现区块链基础功能的密码技术**、**增强区块链隐私保护的密码技术**、**面向区块链业务应用的密码技术**和**区块链中用到的其他密码学技术**四个类别，介绍了区块链中常用的密码技术。对每一个密码技术，本报告介绍其基本概念和定义，安全性质，主要特点和在区块链中的应用，致力于构建一个全面清晰的区块链中密码技术参考文档。

*声明：由于区块链及相应密码学技术发展日新月异，本报告所调研密码学技术可能未穷尽一些重要的或有潜力的用于区块链中的密码技术；更囿于作者知识和视野的不足，错误之处在所难免。恳请同行专家和社区朋友不吝指正。*

本报告由伍前红、王志鹏、翟明哲、赵杭、范家良、代小鹏、高启元等完成，由秘猿科技支持。

[toc] 

## 一、实现区块链基础功能的密码技术

现有的大多数区块链的设计目标是保证所记录的交易由合法的用户创建，一旦记录则无法删除、无法篡改、可以追溯、无法否认，并且系统不能被少数恶意用户所控制。区块链使用杂凑函数与数字签字这两种基础密码技术，并结合全网共同记录和激励机制等系统设定，实现区块链的基本业务功能。

### 1.1 杂凑函数

杂凑函数（Hash function，又称哈希函数）是一类以任意长度比特串为输入，输出固定长度的比特串的函数。密码学中，杂凑函数通常考虑以下两种安全定义：

- 单向性：杂凑函数$H:X\rightarrow Y$ 是单向函数，即对任何有限计算能力的攻击者，给定 $y\in Y$，无法找到$x\in X$，使得$H(x)=y$；
- 抗碰撞性：杂凑函数$H:X\rightarrow Y$ 是抗碰撞的，即对任何有限计算能力的攻击者，无法找到 $x_1,x_2 \in X$，使得$H(x_1)=H(x_2)$。  

杂凑函数是区块链系统中最为重要的密码学工具之一，它具有生成账户地址、构成 [Merkle 树]( https://en.wikipedia.org/wiki/Merkle_tree )和实现工作量证明（Proof of Work， PoW）机制等职能。

利用杂凑函数生成账户地址，是指将签名的公钥作为杂凑函数的输入，输出值作为地址。基于杂凑函数抗碰撞性的特点，可以确保每一个交易地址都是惟一的。同时，杂凑函数生成交易地址，始终使交易地址统一为某一固定比特长度，避免了直接使用公钥作为地址可能造成的地址过长等问题。

在Merkle树中，每一个叶子节点是一个数据块的杂凑值；任意内部节点均有两个子节点，其值是以子节点为输入的杂凑值。Merkle树在区块链系统中的主要作用是打包区块内的交易。具体地，区块内的每一个交易单的杂凑值都对应了Merkle树的一个叶子节点，生成的Merkle树的根被存储在区块的头部区域。

PoW机制可用来实现区块链记账权的分配。具体地，POW 要求所有的参与者寻找一个随机数 nonce，使得以区块头部和 nonce 为输入的杂凑函数输出小于一个固定值 target 。第一个寻找到符合条件的随机数的参与者拥有生成新区块的权利。由于杂凑函数具备单向性，任何人都无法根据指定的输出来寻找对应的输入，获得符合条件的 nonce 的唯一策略是不停的尝试新的随机数进行杂凑运算。因此，获得记账权利的机会和拥有的计算能力是正相关的。

下面介绍目前区块链项目中常用的杂凑函数。

<table> 
  区块链项目中常用的杂凑函数
  <tr>  <th colspan="2">名称</th><th>主要特点</th><th>主要数学依赖/构造方法</th><th>应用项目/研究论文</th></tr> 
  <tr><td rowspan="20">基础杂凑函数</td><td>SHA-256</td><td>NIST 发布的安全哈希算法，尚未发现明显弱点</td><td>Merkle–Damgård 结构</td><td><a href="https://bitcoin.org">Bitcoin</a>、<a href="https://www.ethereum.org">Ethereum</a> 等</td></tr>  
  <tr>                        <td>RIPEMD-160</td><td>较 MD4、MD5、RIPEMD-128 有更好的抗强碰撞能力</td><td>MD4</td><td><a href="https://bitcoin.org">Bitcoin</a></td></tr> 
  <tr>                        <td>BLAKE</td><td>被开发用来避免长度扩展攻击、安全系数很高</td><td>ChaCha 流密码</td><td><a href="https://decred.org">Decred</a>、<a href="https://vergecurrency.com/">verge</a> 等</td></tr> 
  <tr>                        <td>Keccak</td><td>SHA-3 标准算法</td><td>海绵结构</td><td><a href="https://smartcash.cc">SmartCash</a>、<a href="https://maxcoinproject.org">MaxCoin</a> 等</td></tr> 
  <tr>                        <td>Skein</td><td>可变位算法，经过优化使用更少的内存</td><td>Threefish 分组密码</td><td><a href="https://www.digibyte.co/digibyte-global-blockchain">DigiByte</a>、<a href="https://skeincoin.co">Skeincoin</a> 等</td></tr> 
  <tr>                        <td>Grøstl</td><td>与 AES 结构相似，使用同样的 S 盒</td><td>AES</td><td><a href="https://www.groestlcoin.org">Groestlcoin (GRS)</a></td></tr> 
  <tr>                        <td>JH</td><td>适合使用SSE2指令集进行位分片实现</td><td>AES</td><td><a href="https://cryptoslate.com/coins/securecoin/">SecureCoin (SRC)</a></td></tr> 
  <tr>                        <td>Argon2</td><td>可以通过参数配置运行时间、内存消耗及并行度</td><td>Blake2b</td><td><a href="https://aquacha.in">Aquachain</a></td></tr>
  <tr>                        <td>Lyra2</td><td>能够配置所需内存、处理时间和并行性，并能提供高内存使用率</td><td>Blake2b、Keccak、BlaMka</td><td><a href="https://gincoin.io">GINcoin</a>、<a href="https://criptoreal.org">Criptoreal</a> 等</td></tr> 
  <tr>                        <td>Makwa</td><td>基于大整数分解的安全性，仅使用 CPU，不占用内存</td><td>HMAC_DRBG</td><td></td></tr>
  <tr>                        <td>Cuckoo cycle</td><td>有助于保持网络分散避免挖矿中心化，同时受内存带宽限制可减少功耗和发热</td><td>图论</td><td><a href="https://www.merit.me/technology/">Merit</a>、<a href="http://bitcash.jp">BitCash</a> 等</td></tr>
  <tr>                        <td>Balloon</td><td>存储困难，抗缓存攻击，易于实现</td><td>SHA-3，SHA-512 等</td><td></td></tr> 
    <tr> <td>Ethash</td><td>算法中应用 DAG、抗 ASIC</td><td>Keccake256</td><td><a href="https://www.ethereum.org">Ethereum 1.0</a></td></tr>  
  <tr>                        <td>ProgPow</td><td>提高 GPU 挖矿效率，避免算力集中在 ASIC 矿机商手中</td><td>Ethash</td><td><a href="https://www.ethereum.org">Ethereum</a></td></tr> 
  <tr>                        <td>Scrypt</td><td>性能与算力相关不大，但很依赖内存</td><td>PBKDF2、HMAC-SHA256</td><td><a href="https://litecoin.org">Litecoin</a></td></tr> 
  <tr>                        <td>NeoScrypt</td><td>较 Scrypt 安全性更强，提升性能并降低成本</td><td>Scrypt</td><td><a href="http://phoenixcoin.org">Phoenixcoin</a>、<a href="https://trezarcoin.com">TrezarCoin</a> 等</td></tr> 
  <tr>                        <td>Yescrypt</td><td>应用慢加密操作，可根据内存使用情况和并行度调整运行时间</td><td>SHA-256，HMAC、PBKDF2 和 Scrypt</td><td><a href="https://elicoin.net">EliCoin</a>、<a href="http://globalboost-y.com">Globalboost-Y</a> 等</td></tr> 
  <tr>                        <td>Equihash</td><td>增加了内存读取复杂度，验证和证明生成是非对称的</td><td>广义生日问题</td><td><a href="https://z.cash/zh/">Zcash</a>、<a href="https://bitcoingold.org">Bitcoin Gold</a> 等</td></tr> 
  <tr>                        <td>CryptoNight</td><td>需要访问内存、具有延迟依赖性</td><td>Keccak、AES-256</td><td><a href="https://bytecoin.org">Bytecoin</a>、<a href="https://electroneum.com">Electroneum</a> 等</td></tr>
   <tr>                        <td>SM3</td><td>国家商用杂凑函数</td><td>Merkle–Damgård 结构</td><td><a href="https://github.com/Bytom/wiki/blob/master/zh-CN/Bytom-Technical-White-Paper-ZH.pdf">Bytom</a></td></tr>
  <tr><td rowspan="6">复合杂凑函数</td><td>X11/X13/X15/X16r/X17</td><td>把多种密码散列函数串联用来抗 ASIC</td><td>BLAKE、Grøstl、JH、Keccak、Skein 等</td><td><a href="https://www.dash.org">Dash</a>、<a href="https://ravencoin.org">Ravencoin</a> 等</td></tr>  
  <tr>                        <td>Quark</td><td>使用六种不同的加密算法来进行九级加密</td><td>Grøstl、Blue Midnight Wish、Keccak、JH、Skein、Blake</td><td><a href="https://icodrops.com/lockchain/">LockChain</a>、<a href="https://www.dimecoinnetwork.com">Dimecoin</a> 等</td></tr> 
  <tr>                        <td>Lyra2rev2</td><td></td><td>Blake、Keccak、Cubehash、LYRA2、Skein、Cubehash、Blue Midnight Wish</td><td><a href="https://vertcoin.org">Vertcoin</a>、<a href="https://monacoin.org)">MonaCoin</a> 等</td></tr> 
  <tr>                        <td>NIST5</td><td>由五个 SHA-3 候选算法组成</td><td>Blake、Grøstl、JH、Kecaak、Skein</td><td><a href="https://electraproject.org">Electra</a>、<a href="https://bulwarkcrypto.com">Bulwark</a> 等</td></tr> 
  <tr>                        <td>Lbry</td><td></td><td>SHA-256、SHA-512、RIPEMD</td><td><a href="https://lbry.com">LBRY Credits (LBS)</a></td></tr> 
  <tr>                        <td>SkunkHash</td><td></td><td>Skein、Cubehash、Fague、Gost</td><td><a href="https://medium.com/@mark.bouchard/vapecoin-vape-6269809b3219">Vapecoin (VAPE)</a></td></tr> 
</table>

#### 1.1.1 基础杂凑函数

##### 1) SHA-256

**项目应用** 

PoW 中最广泛使用的哈希算法，在[比特币](https://bitcoin.org/en/)、[以太坊](https://www.ethereum.org/zh/)、[莱特币](https://litecoin.org/cn/)等项目中均有使用。

**算法简介**

SHA（Secure Hash Algorithm，安全哈希算法）是一类由美国国家标准与技术研究院（NIST）发布的密码哈希函数。 SHA256 属于著名的 SHA 家族一员，是 SHA-1 的后继者， 它们是使用 [Merkle–Damgård 结构](https://en.wikipedia.org/wiki/Merkle–Damgård_construction)建立的。

**算法流程**

1. 附加填充比特。对报文进行填充使报文长度与 448 模 512 同余（$长度=448mod512$），填充的比特数范围是 1 到 512，填充比特串的最高位为 1，其余位为 0。直到长度满足 $mod 512=448$；
2. 附加长度值。将用 64-bit 表示的初始报文（填充前）的位长度附加在步骤 1 的结果后（低位字节优先）；
3. 初始化缓存。使用一个 256-bit 的缓存来存放该杂凑函数的中间及最终结果；
   该缓存表示为 $A=0x6A09E667$，$B=0xBB67AE85$，$C=0x3C6EF372$ ，$D=0xA54FF53A$，$E=0x510E527F$，$F=0x9B05688C$，$G=0x1F83D9AB$，$H=0x5BE0CD19$；
4. 处理 512-bit（16 个字）报文分组序列。该算法使用了六种基本逻辑函数，由 64 步迭代运算组成。每步都以 256-bit 缓存值 ABCDEFGH 为输入，然后更新缓存内容。每步使用一个 32-bit 常数值 Kt 和一个 32-bit Wt。 

##### 2) RIPEMD-160

**项目应用**

RIPEMD-160 用于[比特币](https://bitcoin.org)中公钥生成地址的过程中。

**算法简介**

RIPEMD（RACE Intergrity Primitives Evaluation Message Digest）：即 RACE 原始完整性校验消息摘要，是比利时鲁汶大学 COSIC 研究小组开发的哈希函数。RIPEMD 使用 MD4 的设计原理，并针对 MD4 的算法缺陷进行改进，1996 年首次发布 RIPEMD-128 版本，它在性能上与 SHA-1 相类似。

RIPEMD-160 是对 RIPEMD-128 的改进，RIPEMD-160 输出 160 位的 Hash 值，对 160 位 Hash 函数的暴力碰撞搜索攻击需要 $2^{80}$ 次计算，设计充分吸取了 MD4、MD5、RIPEMD-128 的一些经验，使其具有更好的抗强碰撞能力。它旨在替代 128 位哈希函数 MD4、MD5 和 RIPEMD。

**算法流程**

1. 一个有 10 个循环的压缩函数模块，其中每个循环由 16 个处理步骤组成；
2. 在每个循环中使用不同的原始逻辑函数，算法的处理分为两种不同的情况，在这两种情况下，分别以相反的顺序使用 5 个原始逻辑函数；
3. 每个循环都以当前分组的消息字和 160 位的缓存值 A、B、C、D、E 为输入得到新的值；
4. 每个循环使用一个额外的常数 K'，在最后一个循环结束后，两种情况的计算结果 A、B、C、D、E 和 A'、B'、C'、D'、E' 及链接变量的初始值经过一次相加运算产生最终的输出；
5. 对所有 512 位的分组处理完成之后，最终产生的 160 位输出即为消息摘要。

除了 128 位和 160 位的版本之外，RIPEMD 算法也存在 256 位和 320 位的版本，它们共同构成 RIPEMD 家庭的四个成员：RIPEMD-128，RIPEMD-160，RIPEMD-256，RIPEMD-320。其中 128 位版本的安全性已经受到质疑，256 位和 320 位版本减少了意外碰撞的可能性，但是相比于 RIPEMD-128 和 RIPEMD-160，它们不具有较高水平的安全性，因为他们只是在 128 位和 160 位的基础上，修改了初始参数和 s-box 来达到输出 256 位和 320 位的目的。

##### 3) BLAKE

**项目应用**

BLAKE 直接用作区块链项目中工作量证明的哈希算法不是很流行，使用 BLAKE 的区块链项目主要包括 [Decred](https://decred.org)(DCR)、Verge、BlakeBitcoin。此外还有些著名的区块链项目使用了基于 BLAKE 的哈希算法。

**算法简介**

SHA-3 决赛候选算法之一。

BLAKE 和 BLAKE2 是基于 Dan Bernstein 的 ChaCha 流密码的密码杂凑函数，但在每个 ChaCha 回合之前添加一个输入块的排列副本，其产生方式为：首先置换输入块的副本，之后将其与一些回合常数进行异或（XOR）。

BLAKE 被开发用来避免[长度扩展攻击](https://zh.wikipedia.org/zh-hans/长度扩展攻击)。

BLAKE 的两个主要实例是 BLAKE-256 和 BLAKE-512。 它们分别使用 32 位和 64 位字，并生成 256 位和 512 位摘要。

在 64 位 x64 和 ARM 体系结构上运行时，BLAKE2b 比 SHA-3，SHA-2，SHA-1 和 MD5 速度更快。BLAKE2 是安全系数最高的哈希算法之一 ，类似于 SHA-3，优于 SHA-2。

**算法流程**

1. 混合函数 G：将两个输入字 x 和 y 混合到工作向量 v[0..15] 中由 a，b，c 和 d 索引的四个字内，之后返回修改过的完整向量；
2. 压缩函数 F：将状态向量 h，消息块向量 m，2w 位偏移量 t 和最终块指示符标志作为参数 F。局部向量 v[0..15] 用于进行处理。F 返回一个新的状态向量。BLAKE2b 执行 12 轮，BLAKE2s 执行 10 轮；
3. 填充数据并计算 BLAKE2 摘要：密钥和数据输入被拆分并填充到 dd 消息块 d[0..dd-1] 中，每个消息块由 16 个字组成。如果使用密钥，则将其填充零字节并将其设置为 d[0]。否则，d[0] 是第一个数据块。最终数据块 d[dd-1] 也用 0 填充为 16 个字。

可参考的 BLAKE2b 的 [算法实现](https://tools.ietf.org/html/rfc7693#appendix-C.2)。

##### 4) Keccak

**项目应用**

[SmartCash](https://smartcash.cc)、MaxCoin、CreativeCoin

**算法简介**

被选为 NIST 哈希算法竞赛的胜利者，成为 SHA-3 标准算法。

Keccak 采用了与 SHA-1、SHA-2 完全不同的海绵结构，输入的数据在进行填充之后，要经过吸收阶段（absorbing phase）和挤出阶段（squeezing phase），先将输入的消息吸收到内部状态并处理，然后再根据内部状态挤出相应的杂凑值。

Keccak 具有快速，设计简单，方便硬件实现等特点。

**算法流程**

分为吸收阶段和挤出阶段。

吸收阶段的流程如下：

1. 将经过填充的输入消息按照每 r 个比特为一组分割成若干个输入分组；

2. 首先，将“内部状态的 r 个比特”与“输入分组 1”进行 XOR，将其结果作为“函数 f 的输入值”；

3. 然后，将“函数 f 的输出值 r 个比特”与“输入分组 2”进行 XOR，将其结果再次作为“函数 f 的输入值”；

4. 反复执行上述步骤，直到到达最后一个输入分组；

5. 待所有输入分组处理完成后，结束吸收阶段，进入挤出阶段。

函数 f 的作用是将输入的数据进行复杂的搅拌操作并输出结果（输入和输出的长度均为 b = r + c 个比特），其操作对象是长度为 b = r + c 个比特的内部状态，内部状态的初始值为 0。也就是说，通过反复将输入分组的内容搅拌进来，整个消息就会被一点一点地“吸收”到海绵结构的内部状态中，就好像水分被一点一点地吸进海绵内部一样。每次被吸收的输入分组长度为 r 个比特，因此 r 被称为比特率（bit rate）。

函数 f 的输入长度不是 r 个比特，而是 r + c 个比特，这意味着内部状态中有 c 个比特是不受输入分组内容的直接影响的（但会通过函数 f 受到间接影响），这里的 c 被称为容量（capacity）。

吸收阶段结束后，便进入了挤出阶段，流程如下：

1. 首先，将“函数 f 的输出值中的 r 个比特“保存为“输出分组 1”，并将整个输出值（r + c 个比特）再次输入到函数 f 中；

2. 然后，将“函数 f 的输出值中的 r 个比特“保存为“输出分组 2”，并将整个输出值（r + c 个比特）再次输入到函数 f 中；

3. 反复执行上述步骤，直到获得所需长度的输出数据。

无论是吸收阶段还是挤出阶段，函数 f 的逻辑本身是完全相同的，每执行一次函数 f，海绵结构的内部状态都会被搅拌一次。

挤出阶段中实际上执行的是“对内部状态进行搅拌并产生输出分组（r 个比特）”的操作，也就是以比特率（r 个比特）为单位，将海绵结构的内部状态中的数据一点一点地“挤”出来，就像从海绵里面把水分挤出来一样。

在挤出阶段中，内部状态 r + c 个比特中的容量（c 个比特）部分是不会直接进入输出分组的，这部分数据只会通过函数 f 间接影响输出的内容。因此，容量 c 的意义在于防止将输入消息中的一些特征泄漏出去。

海绵结构的实现过程中，总共有五个计算步骤，分别是 θ、ρ、π、χ、ι，轮函数需进行 24 轮，可参考其 [伪代码](https://keccak.team/keccak_specs_summary.html)。

keccak 细节可见 [白皮书](https://csrc.nist.gov/csrc/media/projects/hash-functions/documents/keccak-slides-at-nist.pdf)。

##### 5) Skein

**项目应用**

[DigiByte](https://www.digibyte.co/digibyte-global-blockchain)、Myriad、[Skeincoin](https://skeincoin.co)、Auroracoin、Numus、Unitus

**算法简介**

SHA-3 决赛候选算法之一。

Skein 是一种基于 Threefish 分组密码的可变位算法，该算法经过优化以使用更少的内存，旨在抵御任何哈希攻击，并针对 64 位处理器进行了优化。Skein 支持 256、512 和 1024 位的内部状态大小，以及任意的输出大小 。

Threefish 的核心基于 MIX 函数，该函数使用一次加法、常数旋转和 XOR 来转换 2 个 64 位字。[UBI](https://en.bitcoinwiki.org/wiki/Skein#UBI) 链接模式将输入链接值与任意长度的输入字符串组合在一起，并生成固定大小的输出。

Threefish 的非线性完全来自加法运算和异或运算的结合。它不使用 S-boxes。Skein 论文定义了可选功能，例如随机哈希，流密码和密钥生成功能。

Skein 易于挖掘，更灵活，更快，更安全，并且更适用于不同的硬件。该算法比 SHA-256 快三倍，并且可以使用 CPU 和 GPU 进行挖掘。 

**算法流程**

可参考 Skein [官方网站](http://www.skein-hash.info)。

##### 6) Grøstl

**项目应用**

[Groestlcoin](https://www.groestlcoin.org) (GRS)

**算法简介**

SHA-3 决赛候选算法之一。

Grøstl 与 AES 一样使用相同的 S 盒结构。设计者声称在酷睿 2 处理器中其速度达到每字节 21.4 个周期。

像其他 MD5/SHA 家族的哈希函数，Grøstl 将输入资料分成资料块，再重复计算 $h_i$ = f($h_i-1$, $m_i$). 然而，Grøstl 在每次计算后都保留至少相等于最终哈希值两倍大小的数值（512 位或 1024 位），直至计算完成再将尾端数值截尾。压缩函数 f 被定义为：$f(h,m)=P(h⊕m)⊕Q(m)⊕h$。

P 和 Q 置换函数都基于 Rijndael 研发而成，但该函数分别处理 8×8 或 8×16 的字节组，而非 4×4 字节组。每次压缩皆牵涉[四个操作](https://en.wikipedia.org/wiki/Grøstl)。

最后数值经由以下函数算出哈希值：$Ω(h)=h⊕P(h)$，然后截断至所需之长度。

可参考 Grøstl [官方网站](http://www.groestl.info)。

##### 7) JH

**项目应用**

[SecureCoin](https://cryptoslate.com/coins/securecoin/) (SRC)

**算法简介**

SHA-3 决赛候选算法之一。

JH 具有 1024 位状态，最终的摘要是 1024 位最终值的前 224、256、384 或 512 位。它非常适合使用 [SSE2](https://en.wikipedia.org/wiki/SSE2) 指令集进行[位分片](https://en.wikipedia.org/wiki/Bit_slicing)的实现，速度为 16.8 轮/字节。 

处理输入块包括三个步骤：

1. 将输入块异或到状态的左半部分；
2. 对当前状态进行一个 42 轮的无密钥置换（加密功能）。这包括 42 次以下重复：将输入分为 256 个 4 位块，并通过两个 S 盒中的一个映射每个块，该选择由 256 位与轮相关的密钥调度来进行。等效地，将每个输入块与一个键位组合，然后通过 5→4 位 S-box 映射结果；在 GF($2^4$) 上使用 MDS 码混合相邻的 4 位块；置换 4 位块，以使其在接下来的回合中与不同的块相邻；
3. 将输入块异或到状态的右半部分。

可参考 JH [官方网站](https://www3.ntu.edu.sg/home/wuhj/research/jh/index.html)。

##### 8) Argon2

**项目应用**

[Aquachain](https://aquacha.in)

**算法简介**

2013~2015 年密码哈希竞赛（PHC）获胜者。

Argon2 可以通过参数配置运行时间、内存消耗及并行度，实现过程中依赖于 Blake2b。

Argon2 共有三个版本：Argon2d、Argon2i 和 Argon2id。

1. Argon2d 可最大程度地抵抗 GPU 破解攻击。它以密码相关的顺序访问内存阵列，这减少了时空平衡（[TMTO](https://en.wikipedia.org/wiki/Space–time_tradeoff)）攻击的可能性，但可能会遭到侧信道攻击；
2. Argon2i 经过优化，可以抵抗侧通道攻击。它以密码独立的顺序访问内存阵列；
3. Argon2id 是混合版本。它遵循 Argon2i 进行第一次内存遍历，之后使用 Argon2d 进行后续遍历。

**算法流程**

Argon2 使用以两个 1024 字节为输入和一个 1024 字节为输出的内部压缩函数 G，和一个内部哈希函数 $H()$。$H()$ 是 $BLAKE2b(a,|a|,0,x)$ 哈希函数，而压缩函数 G 基于其内部置换。还使用基于 H 的可变长度哈希函数 H'。

具体流程如下：

1. 生成 64 位的值 H_0； 

   ```
             H_0 = H^(64)(LE32(p), LE32(T), LE32(m), LE32(t), LE32(v), 
                     LE32(y), LE32(length(P)), P, LE32(length(S)), S,
                     LE32(length(K)), K, LE32(length(X)), X)
   ```

2. 将内存分配为 m' 个 1024 字节的块；

   ```
             m' = 4 * p * floor (m / 4p)
   ```

3. 对于所有范围在 $[0,p)$ 的 i，计算所有 $B [i] [0]$；

   ```
             B[i][0] = H'(H_0 || LE32(0) || LE32(i))
   ```

4. 对于所有范围在 $[0,p)$ 的 i，计算所有 $B [i] [1]$；

   ```
             B[i][1] = H'(H_0 || LE32(1) || LE32(i))
   ```

5. 对于范围在 $[0,p)$ 的所有 i，以及范围在 $[2,q)$ 的所有 j，计算 $B [i] [j]$。
   对于每个 i，j，对于 Argon2d，Argon2i 和 Argon2id，分别确定块索引 i' 和 j'；

   ```
             B[i][j] = G(B[i][j-1], B[i'][j'])
   ```

6. 如果迭代次数 t 大于 1，我们将重复这些步骤，但是用以下表达式替换计算；

   ```
             B[i][0] = G(B[i][q-1], B[i'][j'])
             B[i][j] = G(B[i][j-1], B[i'][j'])
   ```

7. 迭代 t 步之后，计算最后一列的 XOR 作为最终块 C；

   ```
             C = B[0][q-1] XOR B[1][q-1] XOR ... XOR B[p-1][q-1]
   ```

8. 计算输出标记为 H'(C)。

可参考[参考文档](https://tools.ietf.org/id/draft-irtf-cfrg-argon2-03.html)及[详细代码](https://github.com/P-H-C/phc-winner-argon2)。

##### 9)  Lyra2 

**项目应用**

[GINcoin](https://gincoin.io)、Zoin、Criptoreal 

**算法简介**

Lyra2 是一种哈希函数，也可作为密钥派生函数，在密码哈希竞赛（PHC）中获得了特别肯定。

Lyra2 是 Lyra 的改进，先前由同一作者提出。Lyra2 保留了其前身的安全性，效率和灵活性，能够配置所需内存、处理时间和并行性，并能够以与 scrypt 相似的处理时间提供高内存使用率。

此外，与以前的版本相比，它还带来了重要的改进，具有以下优点： 

1. 可以针对时空平衡攻击提供更高的安全防护级别； 
2. 内存和时间成本可分离，可以根据资源使用情况进行调整；
3. 由于使用减少轮数的内部函数速度更快；
4. 可以提供任何所需长度的输出，作为密钥派生函数（KDF）；
5. 允许合法用户更有效地利用平台的并行处理能力； 
6. 增加用于攻击算法的专用硬件的构建成本； 
7. 它平衡了对便宜存储设备的抗侧信道攻击的抵抗力；
8. 根据不同的目标平台使用不同底层函数，如 Blake2b、Keccak、BlaMka 等。  

Lyra2 是公开发布的，并提供两个主要扩展： 

1. Lyra2δ，使用户可以更好地控制算法的带宽使用； 
2. Lyra2p，使用户可以更好地利用平台的并行处理能力。

**算法流程**

可参考[白皮书](https://eprint.iacr.org/2015/136.pdf)及[伪代码](https://github.com/zcoinofficial/zcoin/wiki/Proof-of-Work-Algorithm)。

##### 10) Makwa

**算法简介**

在密码哈希竞赛（PHC）中获得了特别肯定。

Makwa 具有独特的委托功能和基于大整数分解的安全性。简而言之，Makwa 的核心是对 Blum 整数（一种特定的 RSA 模数）进行重复平方取模，可以使用类似于 RSA 盲签名的技术来进行委托。

Makwa 主要具有以下特点：

1. 基于模数算法；
2. 仅使用 CPU，不占用内存；
3. 代数结构可以实现第三方托管等高级功能；
4. 具有委托功能；
5. 以美国黑熊的名字命名。

**算法流程**

1. 使用任意长度的密码进行预哈希操作；
2. 使用密钥导出函数的用法，加盐产生无偏密码；
3. 对密码进行重复平方取模操作；
4. 使用 HMAC_DRBG 进行哈希和填充。

可参考[白皮书](https://www.bolet.org/makwa/makwa-spec-20140222.pdf)、[详细介绍](http://www.bolet.org/makwa/Makwa-Passwords14LV.pdf)及[伪代码](https://password-hashing.net/wiki/doku.php/makwa)。 

##### 11) Cuckoo cycle

**项目应用**

Merit、Grin coin、[BitCash](http://bitcash.jp)  

**算法简介**

Cuckoo Cycle 是 2014 年由 John Tromp 首次提出的一种基于图论的内存受限 POW 哈希算法。此算法可以在任何设备上进行使用以提供平等的挖矿能力，有助于网络分散避免挖矿中心化。由于受内存带宽的约束，可以减少功耗和散热。

Cuckoo cycle 最初用来防止电子邮件垃圾邮件。简单来说，就是邮件的发送者要做出一定的工作量来证明自己确实有邮件联络的需求，才能成功联络到邮件的接收者，这个过程是需要付出计算成本的。Cuckoo Cycle 是基于图形理论的算法，就是在采用 Siphash 随机生成的 Cuckoo Cycle 二分图里找到固定长度 L 的环，随着图的规模越大，L 值越大，找到符合 L 长度环的难度就越大。这样的算法，在求解（即找环的过程）本身需要比较大的空间来存储对数据的排序，是一种 Memory-Hard 的 PoW 算法， 因此在 ASIC 化的过程中本身就存在一定的难度。
除此之外，Cuckoo Cycle 还可以通过变种实现多种算法，例如可以对二分图里的节点进行二进制末尾舍弃的简化，就可以大大降低求解的难度， 变形为 CuckAToo 算法；而如果对二分图内所有的节点进行分组，组内的节点又存在互相依赖的关系，那么要得到组内的任意一个节点哈希，就要把组内所有节点的哈希计算一遍，这样大大增加了求解的难度，对数据缓存的要求也更高，这种就变形为 CuckARoo 算法。

**算法流程**

1. 对新块头进行哈希处理，nonce 将用作 siphash 函数的输入，siphash 的输出作为 cuckoo 图的节点生成函数的输入，得到 cuckoo 图的所有节点；
2. nonce 将用作 SIPHASH 函数的输入，该函数将为图中的每个元素生成位置对； 
3. 通过剪边，执行 Cuckoo 循环检测算法试图在生成的图中找到解（即长度为 42 的循环）； 
4. 对找到的环进行 Blake2b 哈希并将其与当前目标难度进行比较； 
5. 如果哈希难度大于或等于目标难度，则将块广播到网络，并在下一个块开始工作； 
6. 如果没有找到解决方案，则将区块头中的 Nonce 增加 1，并更新时间戳，以便下一次哈希值迭代。

随着图的规模增大，L 的增大，问题的难度也随之增大。图的稀疏度为 $M/N = 1/2$，平均的度为 1，找到一个长度为 L 的难度为 1/L。要保证 POW 的工作量证明的安全性和公平性，意味着需要所有参与方无法通过某种方法来提高解决问题的概率。Cuckoo Cycle 存在的概率，和图的节点多少，边的多少有关，随着 M、N 的增加，图中寻找到 L 大小的环路概率会趋于稳定。

##### 12) Balloon

**算法简介**

Balloon 是一种新的存储困难型哈希函数，可针对序列攻击提供可靠保护。此算法本身使用较大内存空间，其算法流程是线性的，内部过程均为迭代，内部潜在并行度很低。IO 操作为固定地址读写+随机地址读，每次 IO 操作之间，至少计算了一次 hash 函数。

主要具有以下优点：

1. 具有经过验证的存储困难特性。此哈希函数使用 N 位空间进行计算的难度适度，但是使用比其少得多的空间（例如 N / 8 位）来进行计算却非常昂贵。与许多现有构造相反，此特性可以通过随机预言模型的分析来证明；
2. 以密码原语为基础构建。可以使用任何标准的密码哈希函数（SHA-3，SHA-512 等）作为子例程；
3. 抵抗缓存攻击。Balloon 函数的内存访问模式与进行哈希的密码无关。例如通过多用户系统上的侧信道攻击获得内存访问模式的敌手，不会得知有关密码哈希的信息；
4. 算法实用。Balloon 哈希函数易于实现，与目前最好的实用哈希算法的性能相似。

**算法流程**

1. 扩展：Balloon 算法通过反复调用基于密码和盐的压缩函数H生成伪随机字节，并用来填充一个大的缓冲区；
2. 混合：对内存缓冲区中的伪随机字节执行用户指定的 r 次混合操作，在每个混合步骤中，缓冲区中的每个块 i 都会更新内容。由于 Balloon 函数是参数确定函数，因此依赖关系并不是真正随机选择的，而是从用户选择的特定盐中生成的伪随机比特流确定的；
3. 摘取：在最后一步中，Balloon 算法输出缓冲区的最后一块。

可参考[演示文档](https://people.csail.mit.edu/henrycg/files/academic/pres/asiacrypt16balloon-slides.pdf)、[详细代码](https://github.com/henrycg/balloon/)及[白皮书](https://eprint.iacr.org/2016/027.pdf)。

##### 13) Ethash

**项目应用**

[Ethereum 1.0](https://www.ethereum.org)

**算法简介**

Ethash 的初始版本基于一种称为 Dagger-Hashimoto 的算法，该算法通过结合 Thaddeus Dryja 的 Hashimoto 算法和 Vitalik Buterin 的 Dagger 算法而开发。它被开发来满足 3 个主要功能：抗 ASIC，轻客户端可验证性和全链存储。

Ethash 将 [DAG](https://en.wikipedia.org/wiki/Directed_acyclic_graph)（有向无环图）用于工作量证明算法。具有抗 ASIC的特点，计算的效率基本与 CPU 无关，却和内存大小和内存带宽正相关。

实现算法中，主要依赖于 Keccak256。

**算法流程**

1. 计算 hash 种子，通过检索到特定区块高度的区块头信息生成独立的种子；

2. 根据上述生成的种子，独立生成一个 16MB 的伪随机缓存，每一个节点都需要存储该缓存信息；

3. 根据 16MB 的缓存，生成 1 GB 的数据集，数据集中的每一个条目通过缓存的一部分生成。数据集随着时间推移不断增加。轻节点无需存储该数据集；

4. 挖矿主要通过随机选取数据集中的切片信息，并通过算法聚合生成最终的 hash 值。验证算法能够通过缓存信息生成用于生成 hash 计算所需要用到的数据集中数据，因此轻节点可以只存储缓存数据，即可验证区块。Dagger 还有一个关键的地方，就是确定性。即同一个 epoch 内，每次计算出来的 seed、缓存、dataset 都是相同的。对于同一个区块，矿工和验证者使用的是相同数据集；

5. 大数据集每 30000 个块进行一次更新扩充，因此绝大多数矿工的工作只是读取数据集，而无需重复生成更新数据集。

在此算法中，每次混淆操作都需要从数据集中读取 128 字节。计算单个 hash 函数需要进行 64 次混淆，共需要（128 字节 x 64）= 8 KB 的内存读取。且读取是随机访问（每个 128 字节页面是根据混淆函数伪随机选择的），因此将一小部分数据集放在 L1 或 L2 缓存中不会对提升速度有太大帮助，因为下一次提取的值很可能无法涵盖在 L1 或 L2 缓存。由于从内存中获取数据比混合计算慢得多，因此我们将看到加速混淆计算几乎无法显著进行性能提升。加速 Ethash 哈希算法的最佳方法是加速从内存中提取 128 字节 DAG 页面的速度。

可参考 Ethash 的 [实现细节](https://github.com/ethereum/wiki/wiki/Ethash )。

##### 14) ProgPow

**项目应用**

[以太坊](https://www.ethereum.org)社区提出一类新型的 hash 函数。

**算法简介**

ProgPoW 的设计始于 Ethash 并对其进行修改以尽可能多地提高商用 GPU 利用率，提高 GPU 挖矿效率，避免算力集中在 ASIC 矿机商手中。

主要改动有以下 5 点：

1. 将 keccak f1600（64 位字）改为 keccak f800（32 位字）来减少对总算力的影响；

2. 增加混合状态；

3. 在主循环中添加随机数字序列；

4. 添加支持随机地址的低延时、小规模的缓存读取；

5. 将（动态随机存取存储器）读取从128字节增加到256字节。

目前市场的主流显卡都支持上述特点。虽然定制的 ASIC 矿机也可以用该算法实现，但是可用的效率增加不大。唯一可用的优化是：

1. 删除图形管线（显示，几何引擎，纹理等）；
2. 删除浮点运算；
3. 局部 ISA 调整，比如与 merge 函数完全匹配的指令一样。

这些优化会使其效率增加大约 1.1-1.2 倍，但也远远低于 Ethash 算法的 2 倍或 Cryptonight 算法的 50 倍。

该算法在当前的算法中是抗 ASIC 性能最佳的算法。当前使用该算法的区块链项目包括：Ethereum、Ethereum Classic 等。

##### 15) Scrypt

**项目应用**

[Litecoin](https://litecoin.org)

**算法简介**

Scrypt 算法的核心思想是“哈希计算需要更大的内存空间和时长”，所以算法的性能与算力相关不大，但却很依赖内存。

该算法的初衷是为其备份服务降低 CPU 负荷，减少对于 CPU 计算的依赖。这一算法其实是利用了 CPU 的闲置时间进行计算。Scrypt 算法不仅计算所需的时间长，而且需要的内存也很大。Scrypt 算法计算时会产生一个具有若干个块元素（block element）的数组，对其中的每个块元素，都必须先进行一系列运算生成哈希值，再对整个数组进行运算得到最终的结果。而这些块元素都必须被储存在内存中，因此 Scrypt 算法需要极大的内存空间，本身运算的成本很大。大量内存的硬件成本会推高 ASIC 的硬件成本，非常适合用于对抗 ASIC。

利用 rainbow table 进行暴力攻击更加困难，Scrypt 不仅计算所需要的时间长，而且占用的内存也多，使得并行计算多个摘要异常困难。

该算法有效抵制了专业矿机的使用，避免了算力中心化的趋向，但是，随着 Scrypt 算法的广泛使用，专用于这一算法的矿机也被生产出来，后来诞生的 FPGA 矿机也可以在运用这算法时进行大规模挖矿。

**算法流程**

可参考 Scrypt 的 [标准文档](https://datatracker.ietf.org/doc/rfc7914/?include_text=1)

##### 16) NeoScrypt

**项目应用**

VIVO、[Phoenixcoin](http://phoenixcoin.org)、Innova、[TrezarCoin](https://trezarcoin.com) 

**算法简介**

NeoScrypt 是一种应用于 POW 中的哈希算法，使用 Salsa20 和 Chacha20 来改进 2014 年 6 月发布的 Scrypt 算法，并旨在取代 Scrypt 算法，目前除了穷举攻击之外，没有已知的对未缩减 Salsa20 和 ChaCha20 进行的成功攻击。所以 NeoScrypt 在密码学上安全性更强，NeoScrypt 的内存密集度近似是 Scrypt 的 1.25 倍，能够提升性能并降低成本，而且 NeoScrypt 可以抗 ASIC 。NeoScrypt 算法的特点之一是即使在高负载期间，交易也能快速处理。 

**算法流程**

可参考 NeoScrypt 的[白皮书](http://phoenixcoin.org/archive/neoscrypt_v1.pdf)及[具体实现](https://github.com/ghostlander/NeoScrypt)。

##### 17) Yescrypt

**项目应用**

Myriad、[EliCoin](https://elicoin.net)、[Globalboost-Y](http://globalboost-y.com)

**算法简介**

Yescrypt 可作为密钥派生函数，在密码哈希竞赛（PHC）中获得了特别肯定。它应用慢加密操作，从而创建将来执行加密或存储用以验证密码的密钥。Yescrypt 算法基于 Tarsnap 的 Colin Percival 创造的 scrypt 算法。

Yescrypt 具有以下优点：

1. 此算法可选 ROM 大小，以防止使用僵尸节点；
2. 使用基于整数乘法和本地内存访问速度的计算延迟强化以保证使用最少的时间；
3. 具有抗 TMTO 能力，用更少的内存计算会花费不成比例的更长时间；
4. 可扩展至千字节（RAM）到 TB（RAM + ROM）甚至更高；
5. 安全性基于 SHA-256，HMAC 和 PBKDF2 的安全性；
6. SHA-256，HMAC，PBKDF2 和 scrypt 可在同一代码库中使用；
7. 运行时间可根据内存使用情况和并行性进行调整。 

**算法流程**

可参考 Yescrypt 的[具体实现](https://password-hashing.net/wiki/doku.php/yescrypt)。

##### 18) Equihash

**项目应用**

[Zcash](https://z.cash/zh/)、ZenCash、[Bitcoin Gold](https://bitcoingold.org)  

**算法简介**

Equihash 算法由卢森堡大学的教授开发，该算法基于广义生日问题。该问题的基本描述如下所示：对于 n 位比特的字符串构成的字符串序列 {$X_i$}，找到一个子序列 {$X_{ij}$}，使其满足：$X_{i1} ⊕ X_{i2} ⊕ ···⊕ X_{i_{2^k}}=0$。

当 k = 1 时，显然是一个经典的 hash 碰撞的过程，可以通过进行 $2^{n/2}$ 次搜索找到解。但是当 k > 1 时，且 L 的空间更小时，解法会变得更困难，例如当 k = 2 且 L 大小为 $2^{n/4}$ 时，当前的算法最少需要进行 $2^{n/3}$ 次操作。

从增加内存读取复杂度的角度出发，单位时间内可以完成的工作量证明主要取决于拥有多少内存，而与计算性能关系小。由于此算法，消除内存减少的任何应变都会增加时间复杂度。

Equihash被用于挖矿还有另一个重要的特征是其验证和证明生成是非对称的，即计算的证明很难证明，但很容易验证。大多数内存困难的的方案不提供内存不对称（它们是内存对称的），这意味着验证者必须使用与证明者相同的内存量来验证证明。实际上，验证者必须几乎与证明者一样强大。非对称性有利于交易单的快速确认。

其抵抗 ASIC 的关键是找到两个合适的常数来使得算法耗内存最大。

算法中主要涉及三个参数：n、k、d，区块链项目 Zcash 通过 n=200、k=9 来实现 Equihash。 

时间复杂度：$2^{n/(k+1)+d}$ 、空间复杂度：$2^{k+n/(k+1)}$。

具体内容可参考 Equihash [白皮书](https://ledgerjournal.org/ojs/index.php/ledger/article/view/48/66)。

##### 19) CryptoNight

**项目应用**

[Bytecoin](https://bytecoin.org) (BCN)、[Electroneum](https://electroneum.com) (ETN)、[Dero](https://dero.io) (DERO)、[Karbo](https://karbo.io) (KRB)、[SumoKoin](https://www.sumokoin.org) (SUMO)、[Monero Classic](http://monero-classic.org) (XMC)

**算法简介**

CryptoNight 在运算过程中需要大量的暂存器，在设计架构上对 GPU、FPGA 和 ASIC 不友好。

CryptoNight 算法的主要方面是为所有挖掘它的用户提供平等条款。这样，它使采矿保持分布式，而不是几乎集中化。与其他挖掘算法相比，CryptoNight 的其他优点包括处理器与显卡的快速，稳定，安全且发热量小。

CryptoNight 算法抗 ASIC 的主要依靠以下两点：

1. 需要访问内存：传统的 ASIC 适用于 hash 算法，因为它不需要设备访问内存以提交结果。ASIC 仅受其每秒可执行的计算次数的限制，这是具有内置存储器功能的 CPU 和 GPU 的缺点。因为额外的内存信息提取限制了它们可以执行的计算数量。此外，每次访问内存时，CryptoNight 需要 2 MB 内存。这对于某些 ASIC 来说存在问题，因为它们没有内置的内存功能。
2. 延迟依赖性：延迟是指发出计算和返回结果所需的时间长度，依赖性指的是在返回第一计算结果之前不能执行第二计算的概念，在 CryptoNight 的算法环境中，提交的每一步结果都依赖于之前给出的所有结果。

**算法流程**

运算步骤大概分为四步：

1. 初始化大量伪随机数（存放在暂存器），伪随机指的是结果看起来像是随机产生，但每次输入相同的参数，结果都是一样的。（大概需要 2M 内存）；

2. 对这些伪随机数进行大量读写操作，进行 524288 次；

3. 源数据替换；

4. 选择哈希算法，并对所有的数据进行哈希运算以得到最终结果。

首先使用参数 b = 1600 和 c = 512 。对输入内容进行 Keccak（SHA-3）计算。计算结果的用作 AES-256 密钥并扩展为 10 个循环密钥。申请一个分配了 2 MB 空间的暂存器。从计算结果的 64-191 字节处提取出来数据并分割成 8 个块每个块 16 字节。对每个块进行加密 $aesround()$ 函数执行一轮 AES 加密，对本块执行 SubBytes ShiftRows 和 MixColumns ，其结果与轮密钥进行异或运算。

一轮下来得到的计算结果写入暂存器的前 128 个字节，然后这些结果再次代入加密循环，再把这次循环结果写入暂存器的第二个 128 字节里。这里每次往暂存器里写入下一个 128 字节都代表对先前写入的 128 字节内容在新一轮加密的结果。流程一直循环直到暂存器写满。

在主循环之前对输入内容进行 Keccak 计算后取 0 - 31 字节和 32 - 63 字节进行异或，所得到的 32 字节结果用于初始化。变量 a 和 b 分别各占 16 字节，这两个变量将用于主循环主循环进行 524288 次迭代。

在内存操作完成之后，使用与第一步骤初始化步骤分相同的方式进行 Keccak 计算。最终结果的 32-63 字节扩展成 10 个 AES 循环密钥。

从 Keccak 结果里提取 64 - 191 字节并与暂存器里前 128 个字节进行异或运算。然后结果以与第一步初始化步骤使用相同的方式进行加密计算。计算结果继续与暂存器中的第二个 128 个字节进行异或运算，依次循环加密迭代。

在暂存器的最后 128 个字节进行异或运算后，也就是流程的最后一次加密完成后，将原本 Keccak 结果的 64 - 191 字节内容替换为本次加密内容。然后以 b = 1600 对整个块内容进行排列。根据输出结果选择对应的 hash 函数，其中结果第一个字节的 2 个低位比特用于进行 hash 函数的选择，00 代表 BLAKE-256；01 代表 Groestl-256；02 代表 JH-256；03 代表 Skein-256。最后将所选的哈希函数应用于上一步的数据结果之上，最终结果生成的哈希值就是 CryptoNight 算法的计算输出。

2018 年 5 月，比特大陆推出了 cryptonight 算法的专用矿机，实现了高效的 cryptonight 专用硬件，根据资料显示其实际效率提升在 50 倍以上。至此，为对抗 ASIC 矿机，采 Cryptonight 的门罗币选择了通过不断的修改参数来抵抗矿机，由此也造成了门罗币的周期性分叉。当前使用该算法的区块链项目包括：Monero, Bytecoin 等。

可参考 CryptoNight [白皮书](https://cryptonote.org/cns/cns008.txt )。

##### 20) SM3

**项目应用**

[Bytom](https://github.com/Bytom/wiki/blob/master/zh-CN/Bytom-Technical-White-Paper-ZH.pdf)

**算法简介**

SM3 是中国国家密码密码管理局于 2010 年颁布的一种商用密码杂凑函数。SM3 的消息分组是 512 比特，输出的杂凑值 256 比特。SM3 采用和 SHA256 中类似的 Merkle–Damgård 结构，并且其压缩函数和 SHA256 的压缩函数具有类似的结构， 但 SM3 压缩函数的结构和消息拓展的过程都更加复杂—— SM3 的每一步都使用两个消息字，每一步的扩展能力更强。由于 SM3 算法的快速扩展能力， 完整的 SM3 算法具有抵抗各种已知攻击的能力，有非常高的安全性。

#### 1.1.3 复合杂凑函数

##### 1) X11/X13/X15/X16r/X17

**项目应用**

[Dash](https://www.dash.org)、[Ravencoin](https://ravencoin.org)、[Pigeon coin](https://pigeoncoin.org) 

**算法简介**

X11 被设计用来抵抗 ASIC，把 11 种密码哈希函数串联，按顺序把上一函数之哈希值传递至下一个函数，最后得出一个哈希结果。

X11 包括以下 11 个函数，全部皆为 NIST 哈希函数竞赛之参赛者：

BLAKE、Blue Midnight Wish、Grøstl、JH、Keccak、Skein、Luffa、CubeHash、SHAvite-3、SIMD、ECHO

X11 哈希算法的优势：

1.  增强区块链项目的隐秘性和安全性；
2.  专用集成电路阻力；
3.  机枪池阻力；
4.  均衡发展的 CPU 和 GPU 挖矿；
5.  减少图形处理器能耗和热量输出。

##### 2) Quark

**项目应用**

PIVX、[LockChain](https://icodrops.com/lockchain/)、Quark、ALQO、[Dimecoin](https://www.dimecoinnetwork.com)

**算法简介**

Quark 哈希算法基于一级哈希函数，不需要大量的 RAM。它使用 64 位保护来抵御黑客的攻击，并且以低功耗著称。它使用六种不同的加密算法来进行九级加密。这六个算法分别是 Grøstl、Blue Midnight Wish、Keccak、JH、Skein、Blake。

##### 3) Lyra2rev2

**项目应用**

[Vertcoin](https://vertcoin.org) (VTC)、[MonaCoin](https://monacoin.org) (MONA)、[Verge](https://vergecurrency.com) (XVG)、[Shield](https://shield.sh) (XSH)

**算法简介**

Lyra2rev2 算法由一系列不同的哈希算法组成，其中包括 Blake、Keccak、Cubehash、LYRA2、Skein、Cubehash、Blue Midnight Wish

##### 4) NIST5

**项目应用**

[Electra](https://electraproject.org) (ECA)、Bulwark (BWK)、Coinonat (CXT)、Virta Unique Coin (VUC)、NamoCoin (NAMO)、RG Coin (RGC)、Vites (VITES)

**算法简介**

NIST5 算法由五个 SHA-3 候选算法组成，分别是 Blake、Grøstl、JH、Kecaak、Skein。

##### 5) Lbry

**项目应用**

LBRY Credits (LBS)

**算法简介**

LBRY 由 SHA-256、SHA-512 和 RIPEMD 组成。

##### 6) SkunkHash

**项目应用**

MUNcoin (MUN)、Vapecoin (VAPE)

**算法简介**

SkunkHash 由 Skein、Cubehash、Fague、Gost 组成。



### 1.2 数字签名

数字签名这一概念由 Diffie 和 Hellman 在 1976 年首次提出，它作为手写签名的一种电子模拟，可对数字对象的合法性、真实性进行标记，且提供签名者的承诺。

一个签名方案（在某一消息空间 $\mathbb{M}$）是一个多项式时间算法的三元组（KeyGen, Sign, Verify）：

（1）密钥生成（KeyGen）：一个随机化算法，输入为安全参数 K，输出密钥对（vk，sk），其中 sk 是签名密钥，vk 是验证密钥。

（2）签名（Sign）：一个随机化算法，输入签名密钥 sk 和要签名的消息 $M\in \mathbb{M}$，输出一个签名 $\sigma$（表示为 $\sigma = Sign_{sk}( M )$）。

（3）验证（Verify）：一个确定性算法，输入验证密钥 vk、签名的消息 $M\in \mathbb{M}$ 和签名 $\sigma$，输出 1 或 0（1 表示签名有效，0 表示签名无效）。

目前区块链中常用的数字签名方案主要包括：基于椭圆曲线（EC）的签名方案，其安全性基于椭圆曲线上的离散对数问题；基于双线性对的签名方案；基于格基困难问题的签名方案。

区块链能在去中心化的系统中确保交易双方身份真实可靠，且保证数据不被篡改，很大程度上得益于运用了数字签名技术。以 Bitcoin 为例，用户 A 在发起一笔交易时，需要对这笔交易的信息计算哈希值，再用自己的私钥对该信息进行签名，然后将交易信息和数字签名一起广播给 Bitcoin 矿工。Bitcoin 矿工在接收到这笔交易后，需要用 A 的公钥对签名进行验证。如果验证通过才能证明这笔交易确实是用户 A 发出的，且信息没有经过篡改。

Bitcoin 作为区块链的发源项目，在设计时就采用了基于椭圆曲线实现的 ECDSA 签名算法。随后出现的以太坊、瑞波等区块链项目均采用了相同的签名算法，也有相当多项目选择了 EdDSA 等其他签名方案。这里对目前区块链中采用的不同签名算法以及较复杂的签名方案做简单梳理。

<table> 
                               基本签名算法梳理
  <tr>  <th>名称</th><th>主要特点</th><th>主要数学依赖/构造方法</th><th>应用项目/研究论文</th></tr> 
  <tr><td>ECDSA</td><td>椭圆曲线对 DSA 的模拟</td><td>椭圆曲线、离散对数问题</td><td><a href="https://bitcoin.org/">Bitcoin</a>、<a href="https://www.ethereum.org/">Ethereum</a>、<a href="https://www.dash.org/">Dash</a>、<a href="https://www.ripple.com/">Ripple</a> 等</td></tr>  
  <tr>                        <td>EC-Schnorr</td><td>支持聚合签名的签名方案</td><td>椭圆曲线、离散对数问题</td><td><a href="https://www.bitcoincash.org/">Bitcoin Cash<a>、<a href="https://zilliqa.com/">ZILLIQA</a> 等</td></tr> 
  <tr>                        <td>EdDSA</td><td> Schnorr 签名方案在 Edwards 曲线上实现的一种变体</td><td>Twisted Edwards 曲线、离散对数问题</td><td><a href="https://www.stellar.org/">Stellar</a>、<a href="https://cosmos.network/">Cosmos</a>、<a href="https://www.getmonero.org/">Monero</a>、<a href="https://z.cash/zh/">Zcash</a> 等</td></tr> 
  <tr><td>BLS</td><td>基于椭圆曲线的线性配对的签名方案</td><td>椭圆曲线、双线性配对、曲线哈希</td><td><a href="https://dfinity.org/">Dfinity</a> 等</td></tr>
</table>

#### 1.2.1 ECDSA 签名算法 

**ECDSA 的基本定义**

ECDSA（Elliptic Curve Digital Signature Algorithm）椭圆曲线数字签名算法作为椭圆曲线对 DSA 的模拟，由 Scott 和 Vanstone 在 1992 年提出，随后作为 ANSI 标准、 IEEE 标准等被采纳。其安全性基于椭圆曲线上的离散对数问题，比起传统基于离散对数问题的方案，ECDSA 的计算参数更小、密钥更短、签名也更短小。

此算法定义于有限域 $\mathbb{F}_p $ 上，参数包含六元组 $T = (p,a,b,G,n,h)$，其中：

 $p \in \mathbb{Z}$ 是有限域的阶数，要求 $p$ 为一个大素数 ；

$a,b \in \mathbb {F}_p$ 为该有限域上椭圆曲线 $E(\mathbb{F}_p)$ 的参数，其方程为
$$
E: y^2 \equiv x^3 + ax + b\quad(mod\quad p)
$$
$G=(x_G,y_G)$ 为椭圆曲线上的一个基点；

$n\in \mathbb{Z}$ 为子群 $\mathbb{G}=<G>$的阶数；

$h\in \mathbb{Z}\ ,  h = \# E(\mathbb{F}_p)/n$ 为辅因子。

**ECDSA 的算法思路**

> $KeyGen$： 
>
> **输入**：参数组 $T(p,a,b,G,n,h)$
>
> **输出**：密钥对 $(d,Q)$
>
> 1. 产生（伪）随机数 $ d\stackrel{\$}\longleftarrow[1,n-1]$ 作为签名私钥
>
> 2. 计算 $dG =Q$ 作为公钥
>
> 3. 返回密钥对 $(d,Q)$

> $Sign$： 
>
> **输入**：参数组 $T(p,a,b,G,n,h)$，消息 $m$ 和密钥对 $(d,Q)$
>
> **输出**： 签名 $ (r,s) $
>
> 1. 产生（伪）随机数 $ k\stackrel{\$}\longleftarrow[1,n-1]$ 
> 2. 计算 $kG = (x_1,y_1)$ 
> 3. 计算 $r=x_1 \quad mod\quad n$，若 $r=0$ 则返回第一步
> 4. 计算消息的哈希值 $e = H(m)$
> 5. 计算 $s=k^{-1}(e+dr)\  mod\quad n$，若 $s=0$ 则返回第一步
> 6. 返回签名 $(r,s)$

> $Verify$：
>
> **输入**：参数 $T(E(\mathbb{F}_p),p,a,b,G, n,h)$，消息 $m$ ，密钥对$(d,Q)$，签名 $ (r,s) $
>
> **输出**：1（签名通过验证），0（签名未通过验证）
>
> 1. 判断 $r,s \in [1,n-1]$，若不成立，返回 0
> 2. 计算消息的哈希值 $e=H(m)$
> 3. 计算 $s$ 的逆 $s^{-1}$
> 4. 计算 $R' =(x',y')=s^{-1}(hG+rP)$
> 5. 如果 $R'= \mathcal{O}$，返回 0
> 6. 如果 $x'\quad mod\quad n=r $，返回 1

**ECDSA 在区块链中的应用**

Bitcoin 及 Ethereum 等众多区块链项目均使用了基于 Koblitz 曲线 （secp256k1 曲线）实现的 ECDSA 签名算法。Bitcoin 在实现 ECDSA 算法时，使用交易（实际为交易中某些数据的哈希值）作为被签名的消息，签名密钥为用户的私钥。算法主要在 Bitcoin 的脚本函数```OP_CHECKSIG```，```OP_CHECKSIGVERIFY```，```OP_CHECKMULTISIG```和```OP_CHECKMULTISIGVERIFY```中被使用。这里给出高效密码学标准中与该曲线相关的 $\mathbb{F}_p $ 上的推荐椭圆曲线域参数。使用推荐参数可使标量乘法等运算效率显著提高，同时也可以降低算法中存在后门的风险。

参数由六元组 $T =（p，a，b，G，n，h）$ 指定，其中：

有限域 $\mathbb{F}_p $ 定义为：
$$
p = FFFFFFFF\quad FFFFFFFF\quad FFFFFFFF\quad FFFFFFFF
$$

$$
FFFFFFFF \quad FFFFFFFF\quad FFFFFFFE\quad FFFFFC2F
$$

$$
= 2^{256} - 2^{32} - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1
$$

$\mathbb{F}_p$ 上的曲线 $E：y^2 = x^3 + ax + b $ 由下式定义：
$$
a = 00000000\quad 00000000\quad 00000000\quad 00000000\quad00000000\quad 00000000\quad 00000000\quad 00000000
$$

$$
b = 00000000\quad 00000000\quad 00000000\quad00000000\quad00000000\quad 00000000\quad 00000000\quad\quad 00000007
$$

压缩形式的基点 G 为：
$$
G =02\quad 79BE667E\quad F9DCBBAC\quad 55A06295\quad CE870B07\quad CE870B07\quad 029BFCDB\quad 2DCE28D9\quad 59F2815B\quad 16F81798
$$
且未压缩形式为：
$$
G =04\quad 79BE667E\quad F9DCBBAC\quad 55A06295\quad CE870B07\quad029BFCDB\quad
$$

$$
2DCE28D9\quad59F2815B\quad 16F81798\quad 483ADA77\quad 26A3C465\quad 5DA4FBFC\quad
$$

$$
0E1108A8\quad FD17B448\quad A6855419\quad 9C47D08F\quad FB10D4B8
$$

最后，G 的阶数 n 和辅因子 h 为：
$$
n = FFFFFFFF\quad FFFFFFFF\quad FFFFFFFF\quad FFFFFFFE\quad BAAEDCE6\quad AF48A03B\quad BFD25E8C\quad D0364141
$$

$$
h = 01
$$

*ECDSA 的参考代码*

C 语言库： https://github.com/bitcoin-core/secp256k1 

Rust 语言库： https://github.com/bitcoinjs/tiny-secp256k1 

*ECDSA 的算法评价*

基于 secp256k1 的 ECDSA 签名方案在实际区块链场景中实现时存在一定的风险。首先由于 secp256k1 不具有数理完备性，在实现算法时容易在边界情况下产生错误的结果。其次 ECDSA 方案存在私钥泄露的风险，比如随机数 $k$ 值泄露、随机数 $k$ 值重用均会导致签名使用的私钥被泄露。此外，ECDSA 算法对每一次交易都需要进行一次私钥签名。因而对于有多笔输入的交易者并不友好，其支付给矿工的手续费会十分高昂。

#### 1.2.2 EC-Schnorr 签名算法

**EC-Schnorr 的基本定义**

Schnorr 签名方案于 1988 年作为对 El-Gamal 和 Fiat-Shamir 签名方案的改进，由德国数学家、密码学家 Claus Schnorr 提出，并于 1990 年申请了 US 专利保护。这使得此算法此前并未实现标准化。Schnorr 算法的优点之一是能够压缩多签名方案的签名数据。据估计，Schnorr 签名将使 Bitcoin 中的签名空间至少减少 25％。另外，此签名算法可使签名看起来与常规的单个公钥没有区别，十分有利于用户隐私。 

EC-Schnorr 方案为 Schnorr 签名在椭圆曲线上的实现，这里的定义参考了 BSI 相关实现方案。 

此算法定义于有限域 $\mathbb{F}_p $ 上，参数包含六元组 $T = (p,a,b,G,n,h)$，其中：

 $p \in \mathbb{Z}$ 是有限域的阶数，要求 $p$ 为一个大素数 ；

$a,b \in \mathbb {F}_p$ 为该有限域上椭圆曲线 $E(\mathbb{F}_p)$ 的参数，其方程为
$$
E: y^2 \equiv x^3 + ax + b\quad(mod\quad p)
$$
$G=(x_G,y_G)$ 为椭圆曲线上的一个基点；

$n\in \mathbb{Z}$ 为子群 $\mathbb{G}=<G>$的阶数；

$h\in \mathbb{Z}\   h = \# E(\mathbb{F}_p)/n$ 为辅因子。

**EC-Schnorr 的算法思路**

> $KeyGen$：
>
> **输入**：参数组 $T(p,a,b,G,n,h)$
>
> **输出**：密钥对 $(d,Q)$
>
> 1. 产生（伪）随机数 $ d\stackrel{\$}\longleftarrow[1,n-1]$ 作为签名私钥
> 2. 计算 $dG =Q$ 作为公钥
> 3. 返回密钥对 $(d,Q)$

> $Sign$： 
>
> **输入**：参数组 $T(p,a,b,G,n,h)$，消息 $m$ 和密钥对 $(d,Q)$
>
> **输出**： 签名 $(r,s)$
>
> 1. 产生（伪）随机数 $ k\stackrel{\$}\longleftarrow[1,n-1]$ 
> 2. 计算 $R=kG = (x_1,y_1)$ 
> 3. 将 $x_1$ 转换为 八位字节串，计算 $r = H(m||x_1)$，并将结果转换为整数
> 4. 如果 $r=0\ \ mod\ \ n$ 则返回第一步
> 5. 计算 $s=k-r\cdot d_A\ \ mod\ \ n$
> 6. 如果 $s=0$，返回第一步
> 7. 返回签名 $(r,s)$

> $Verify$：
>
> **输入**：参数 $T(p,a,b,G, n,h)$，消息 $m$ ，密钥对$(d,Q)$，签名 $ (r,s) $
>
> **输出**：1（签名通过验证），0（签名未通过验证）
>
> 1. 判断 $r\in[0,n-1],\ s \in [1,n-1]$，若不成立，返回 0
> 2. 计算 $P=(x_P,y_P)=[s]G+[r]Q$，若 $P=\mathcal{O}$，返回 0
> 3. 计算 $v=H(m||x_P)$，并将结果转化为整数
> 4. 判断等式 $v=r$ 是否成立
> 5. 如果等式成立，返回 1；否则返回 0

**EC-Schnorr 在区块链中的应用**

目前使用 Schnorr 签名算法的区块链项目不如使用传统 ECDSA 方案的项目那么多，但也有不少项目陆续转用这一隐私性及扩展性更好的签名方案。比如 [Bitcoin Cash](https://www.bitcoincash.org/) 就已经于 2019 年 5 月 15 日将原先的 ECDSA 签名方案替换为 Schnorr 方案。根据其官方报道，这项升级使得签名大小由先前的 70 字节减少至 64 字节，整个交易的规模相较之前下降了 4%。

*EC-Schnorr 的参考代码*

https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki 

*EC-Schnorr 的算法评价*

除了签名更加短小之外，Schnorr 签名还拥有两个最主要的优点：**支持聚合签名**和**隐藏密钥对**。 Schnorr 允许将多个签名和公钥组合成一个签名或公钥，使其与单签名事务难以区分。如果 Alice 和 Bob 一起在事务上签名，验证者无法知道其有多个签名。Schnorr 还允许对公钥和私钥进行修饰以进行伪装。比如可以将私钥和公钥同时乘上一个标量，这对变换后的密钥仍然相对应，并可以完成签名和验证。这样优秀的特性归功于 Schnorr 签名方案的线性。这让 Schnorr 签名可以在多笔交易输入时大幅降低签名的大小，很好地原生支持多重签名方案的设计。后文对于区块链上多重签名的研究现状有更详细的总结。

#### 1.2.3 EdDSA 签名算法

**EdDSA 的基本定义**

EdDSA (Edwards-Curve Digital Signature Algorithm) 是 Schnorr 签名方案在 [Edwards 曲线](https://en.wikipedia.org/wiki/Edwards_curve)上实现的一种变体。常见的实例有 Ed25519、Ed448 等。[Ed25519](https://ed25519.cr.yp.to/) 是在扭曲爱德华兹曲线（Twisted Edwards curves）上实现的。它具有速度快，密钥较短，安全性高等优点。 

EdDSA 具有以下 11 个参数：

1. 奇质数幂 $p$ ，为有限域 $\mathbb{GF}(p)$ 的阶

2. $b\in\mathbb{Z}$， $2 ^{b-1}> p$

   > EdDSA 公钥恰好具有 $b$ 位，而 EdDSA 签名恰好具有 $2b$ 位。
   > 建议 $b$ 为 8 的倍数，可使公钥和签名长度是八位字节的整数。

3. 有限域 $\mathbb{GF}(p)$ 的元素的 $b-1$ 位编码

4. 杂凑函数 $H$，具有 $2b$ 位输出

   > 建议使用保守的杂凑函数（即在其中不可能产生冲突的杂凑函数），并且对 EdDSA 的总成本没有太大影响。

5. $c\in \mathbb{Z}$，取值为 2 或 3

   > EdDSA 中的秘密标量是 $2 ^ c$ 的倍数。整数 c 是辅因子的以 2 为底的对数。

6. $n\in\mathbb{Z}\quad c \le n <b$

   > EdDSA 中的秘密标量具有 n + 1 位，最高位（第 $2 ^ n$ 位）始终预设，最低 c 位始终清零。

7. $d\in\mathbb{GF}(p)$，非平方元素

   > 通常建议将其取为最接近零的值。

8. $a\in\mathbb{GF}(p),\ a\ne0$，非零平方元素

   > 通常的最佳性能建议是：
   >
   > 如果 $p\quad mod\quad 4 = 1$，则 $a = -1$；
   >
   > 如果 $p\quad mod\quad 4 = 3$，则 $a = 1$ 。

9. $B\ne(0,1), B \in E =\{(x,y)\in\mathbb{GF}(p)^2|ax^2 + y ^ 2 = 1 + dx ^ 2  y ^ 2\}$

10. 奇数质数 $L$，使得 $[L]B = 0,\ 2 ^ c L = \#E$

    > $[L]B$ 表示 $B$ 自身相加 $L$ 次 。
    >
    > 曲线上的加法定义如下：$(x_3,y_3)=(x_1,y_1)+(x_2,y_2)$
    >
    > $x_3=\frac{x_1x_2+x_2y_1}{1+x_1x_2y_1y_2d}$，$y_3=\frac{y_1y_2-ax_1x_2}{1-x_1x_2y_1y_2d}$
    >
    > 数字 $\#E$（曲线上的点数）是为椭圆曲线 E 提供的标准数据的一部分，或可由【**辅因子*阶数**】计算得到。

11. “预杂凑”函数 $PH$

    > PureEdDSA 指使用恒等函数作为 $PH$ 的方案，即 $PH(M)=M$
    >
    > HashEdDSA 指无论消息有多长，$PH$ 都会生成短输出的方案，
    > 如 $PH(M)= SHA-512(M)$。
    >
    > 因此在出现哈希碰撞的情况下，HashEdDSA 无法保证安全性，而 PureEdDSA 则不会受到影响。

**EdDSA 的算法思路**

> $KeyGen$：
>
> **输入**：参数 $(p,b,ENC,h,c,n,d,a,B,L,PH)$
>
> **输出**：密钥对 $(k,ENC(A))$
>
> 1. 随机生成长度为 $b$ 的二进制数 $k$ 作为私钥 
>
> 2. 对 $k$ 计算哈希 $h=H(k) = (h_0, . . . , h_{2b−1})$ 
>
> 3. 计算 $a = 2^n+ \sum_{c≤i≤n-1} 2^ih_i$ 
>
> 4. 计算 $A =(x_A,y_A)= aB$
>
> 5. 计算 $A$ 的编码 $\underline{A}=ENC(A)$ 作为公钥
>
> 方法：首先计算 $y_A$ 的 $(b-1)$ 位编码；若 $x$ 为负，则将其与 1 相连；如果 $x$ 不为负，则与 0 相连。
>
> 6. 返回密钥对 $(k,ENC(A))$

> $Sign$：
>
> **输入**：参数 $(p,b,ENC,h,c,n,d,a,B,L,PH)$，消息 $M$
>
> **输出**：签名 $(ENC(R)||ENC(S))$
>
> 1. 计算 $r = H(h_b, . . . , h_{2b−1}, M) ∈ \{0, . . . , 2^{2b} − 1\}$ 
> 2. 计算 $R = [r]B$ 
> 3. 计算 $S = (r + H(ENC(R)||ENC(A)||PH(M))a) \ \ mod\ \  L$
> 4. 返回签名 $(ENC(R) ||ENC(S))$ 

> $Verify$：
>
> **输入**：参数 $(p,b,ENC,h,c,n,d,a,B,L,PH)$，消息 $M$ ，密钥对 $(k,ENC(A))$，签 名 $(ENC(R) ||ENC(S))$ 
>
> **输出**：1（签名通过验证），0（签名未通过验证）
>
> 1. 分别由 $ENC(A),\ ENC(R)$ 计算出$A,R$
> 2. 若 $A\notin E$ 或$\ R\notin E$ 或 $S\notin \{0,1,...,L-1\}$，返回 0
> 3. 计算 $H(ENC(R),ENC(A),M)$
> 4. 判断方程组 $[2^cS]B=2^cR+[2^ch]A$ 是否成立
> 5. 若方程成立，返回 1；若不成立，返回 0

**EdDSA 在区块链中的应用**

由于 EdDSA 签名机制特性良好，许多区块链项目（包括 Cosmos， Monero， Zcash 等）采纳了这一机制，且选择了其在设计机制透明的 Curve25519 曲线上的实例：Ed25519 签名机制。根据 RFC 8032，此实例具有 128 比特安全强度，其设计者称在此条件下 Ed25519 可以达到 10 万/秒的签名速度和 7 万/秒的验签速度。此外，作为 PureEdDSA 的实例，签名过程的安全性也不依赖杂凑函数的防碰撞性。

这里给出 Ed25519 采取的参数：

> $$p=2^{255} - 19$$
>
> $b=256$                                                  
>
> $encoding\ of\ \mathbb{GF}(p)$ : 255-bit little-endian encoding of $\{0, 1, ..., p-1\} $
>
> $H(x)=SHA-512(x)$            
>
> $c=3$    
>
> $n=254$                                                   
>
> $d =-121665/121666 = 37095705934669439343138083508754565189542113879843219016388785533085940283555$$a=-1$           
> $$
> \begin{aligned}
> B=&\left(15112221349535400772501151409588531511454012693041857206046113283949847\right.\\
> &\left. 762202,46316835694926478169428394003475163141307993866256225615783033603165251855960\right)
> \end{aligned}
> $$
> $L=2^{252}+27742317777372353535851937790883648493$
>
> $PH(x)$：恒等函数                       

*EdDSA 的参考代码*

C 语言库  https://github.com/jedisct1/libsodium/tree/master/src/libsodium/crypto_core/ed25519 

Rust 语言库 https://github.com/dalek-cryptography/curve25519-dalek

*EdDSA 的算法评价*

此方案在签名过程中实际使用了密码学杂凑函数来代替传统 Schnorr 算法中的伪随机数发生器，使得一些由于算法采用的随机数生成器不够随机化产生的安全问题得以被避免。另外，在整个签名和验签过程中，除了生成私钥的步骤，其余部分均无需依赖随机数发生器，从而直接在签名机制内避免了因为随机化问题导致的密钥泄露与安全性问题。 

#### 1.2.4 BLS 签名算法

**BLS 的基本定义**

[BLS](https://www.iacr.org/archive/asiacrypt2001/22480516.pdf) 签名方案是由斯坦福大学教授 Dan Boneh 等人于 2001 年提出的一种签名方案。 方案基于曲线哈希（hashing to the curve）以及曲线配对（curves pairing）设计。此方案设计得十分简洁，得到的签名也十分短小。经过优化后的签名用压缩的序列化格式保存，只占 33 个字节。 

**BLS 的算法思路**

> $KeyGen$： 
>
> **输入**：参数组 $T(p,a,b,G,n,h)$
>
> **输出**：密钥对 $(d,Q)$
>
> 1. 产生（伪）随机数 $ d\stackrel{\$}\longleftarrow[1,n-1]$ 作为签名私钥
>
> 2. 计算 $dG =Q$ 作为公钥
>
> 3. 返回密钥对 $(d,Q)$

> $Sign$： 
>
> **输入**：参数组 $T(p,a,b,G,n,h)$，消息 $m$ 和密钥对 $(d,Q)$
>
> **输出**： 签名 $ (r,s) $
>
> 1. 计算曲线哈希 $h=H(m)$
> 2. 计算签名 $s=d*h$
> 3. 返回签名 $s $

> $Verify$：
>
> **输入**：参数 $T(E(\mathbb{F}_p),p,a,b,G, n,h)$，消息 $m$ ，密钥对$(d,Q)$，签名 $ (r,s) $，配对函数 $e()$
>
> **输出**：1（签名通过验证），0（签名未通过验证）
>
> 1. 判断等式 $e(Q, H(m)) = e(G, s) $ 是否成立，成立则返回 1，否则返回 0

**BLS 在区块链中的应用**

BLS 算法可将区块中的所有签名都可以组合成单个签名，因此十分适合于构造 m-n 类型的多重签名。比如  Dan Boneh 就于 2018 年提出了基于 BLS 构造的 [多重签名方案](https://eprint.iacr.org/2018/483.pdf)。

*BLS 的算法评价*

BLS 签名算法能将区块中的签名聚合成单一签名，可以进行密钥聚合和 m-n 多重签名（无需额外通信），且避免了使用随机数生成器。但在验证过程中使用的配对函数计算比起 ECDSA 等其他方案来说效率太低。

## 二、增强区块链隐私保护的密码技术

Bitcoin 基于假名机制保护用户的隐私，即允许用户离线生成多个交易地址来参与交易，使得他人无法将用户和某一地址一一对应。然而，Bitcoin 依赖普通的数字签名技术来验证交易的合法性，这使得关联交易之间的对应关系是全网公开可见的。目前已有大量的工作表明，利用类似于社交网络关系分析的技术，可以从区块链上数据中恢复出显式的交易图，从而破坏交易的匿名性。

目前增强区块链系统用户隐私的多种技术手段都遵循同一种启发式思想，即混币。通过混币机制，区块链上记录的交易数据将不再能反应交易单直接的关联性，而是体现为某一笔交易的来源交易属于某个交易单集合。直观的，交易单集合越大，混币机制提供的匿名性也就越强。而当交易链条中的多数交易都通过混币机制完成，恢复出真实交易路径的难度也将指数级的增大。因此混币机制可以有效地抵抗基于交易图的去匿名化分析，为区块链系统提供更强的隐私保护。根据实现方式是否依赖于某个或数个中心化机构，混币机制可以分为去中心化混币机制和中心化混币机制。大多数混币协议都使用盲签名、环签名、零知识证明协议等密码学技术。

<table> 
                               增强区块链隐私保护的密码技术
  <tr>  <th colspan="2">名称</th><th>主要特点</th><th>主要数学依赖/构造方法</th><th>应用项目/研究论文</th></tr> 
  <tr><td rowspan="6">高级数字签名协议</td><td>盲签名</td><td>允许签名者在无法获取消息内容和签名结果的情况下签名</td><td>RSA、双线性对、椭圆曲线</td><td><a href="https://link.springer.com/chapter/10.1007%2F978-3-662-48051-9_9">Blindcoin</a> 等</td></tr>  
  <tr>                        <td>环签名</td><td>使得一组织中任意成员可用自己的私钥和其他成员的公钥进行签名，且无需管理员</td><td>公钥数字签名</td><td><a href="https://cryptonote.org/whitepaper.pdf">CryptoNote</a>、<a href="https://www.getmonero.org/">Monero</a> 等</td></tr> 
  <tr>                        <td>群签名</td><td>使得一组织中任意成员可以匿名代表群体进行签名，具有特权的群管理员可对争议签名追踪出真正的签名者</td><td>公钥数字签名、承诺、非交互式零知识证明</td><td><a href="https://www.orbs.com/">Orbs</a>、<a href=" https://www.orbs.com/white-papers/helix-consensus-whitepaper/">Juzix</a> 等</td></tr> 
  <tr>                        <td>多重签名</td><td>能够使多个不同的签名者对同一消息生成一个签名</td><td>公钥数字签名、承诺</td><td><a href="https://blockstream.com/2019/02/18/en-musig-a-new-multisignature-standard/">MuSig</a> 等</td></tr> 
  <tr>                        <td>聚合签名</td><td>能够将多个不同的签名者产生的多个签名聚合成一个较短的签名</td><td>RSA 问题、双线性映射、格基困难问题</td><td>
    <a href="https://link.springer.com/chapter/10.1007/978-3-030-17653-2_22">Mimblewimble</a> 、
    <a href="https://eprint.iacr.org/2017/406.pdf">OmniLedger</a> 等</td></tr> 
  <tr>                        <td>门限签名</td><td>群体内超过一定数量的合法诚实成员可以代表此群体用群私钥进行签名</td><td>门限秘密共享、公钥数字签名</td><td><a href="https://github.com/KZen-networks/">ZenGo</a>、<a href="https://github.com/Turing-Chain/TSSKit-Threshold-Signature-Scheme-Toolkit">TSSKit</a> 等</td></tr> 
     <tr><td rowspan="5">承诺和零知识证明协议</td><td>承诺协议</td><td>绑定性和隐藏性</td><td>杂凑函数、离散对数</td><td><a href="http://zerocoin.org/">Zerocoin</a>、
         <a href="https://www.getmonero.org/">Monero</a> 等</td></tr>    
    <tr><td>NIZK</td><td>非交互</td><td>双线性对、Fiat-Shamir转换</td><td><a href="http://zerocoin.org/">Zerocoin</a></td></tr>
    <tr><td>zk-snark</td><td>简洁高效</td><td>双线性对、拉格朗日插值、椭圆曲线</td><td><a href="http://zerocash-project.org/">Zerocash</a></td></tr> 
    <tr><td>Bulletproofs</td><td>简洁高效，空间复杂度低</td><td>双线性对、拉格朗日插值、离散对数</td><td><a href="https://link.springer.com/chapter/10.1007/978-3-030-17653-2_22">Mimblewimble</a></td></tr> 
    <tr><td>zk-stark</td><td>可扩展透明、抗量子</td><td>双线性对、离散对数、快速离散傅立叶</td><td><a href="https://www.starkware.co/">Starkware</a></td></tr> 
  <tr><td colspan="2">累加器</td><td>支持成员关系证明和动态更新、支持非成员关系证明</td><td>Strong RSA 假设、双线性对、杂凑函数/Merkle 树</td><td>
      <a href="http://zerocoin.org/">Zerocoin</a>、
      <a href="http://zerocash-project.org/">Zerocash</a>、
      <a href="https://www.getmonero.org/">Monero</a> 等</td></tr> 
  <tr><td colspan="2">伪随机函数</td><td>带有密钥的函数族、伪随机性</td><td>DDH 困难问题、杂凑函数</td><td><a href="http://zerocash-project.org/">Zerocash</a>、
      <a href="https://www.getmonero.org/">Monero</a> 等</td></tr> 
</table>

### 2.1 高级数字签名协议

#### 2.1.1 盲签名

**盲签名的基本定义**

1982 年 Chaum 提出了 [盲签名](https://sceweb.sce.uhcl.edu/yang/teaching/csci5234WebSecurityFall2011/Chaum-blind-signatures.PDF) 的概念。盲签名允许使用者获得一个消息的签名，而签名者既不知道该消息的内容，也不知道该消息的签名。盲签名可用于需要提供匿名性的密码协议中，如电子投票和电子现金。

一个盲签名方案由以下部分组成：

1. 消息盲化：使用者利用盲因子对要签名的信息进行盲化处理，然后将盲化后的消息发送给签名者。

2. 盲消息签名：签名者对盲化后的消息进行签名，因此他并不知道真实消息的具体内容。

3. 恢复签名：使用者除去盲因子，得到真实消息的签名。

**盲签名在区块链中的应用**

*盲签名与混币*

盲签名技术主要用来辅助增强使用 [Bitcoin Core](https://bitcoin.org/en/bitcoin-core/) 共识的区块链中的匿名性。其最突出的应用为中心化混币方案。

混币基于匿名通信的思想提出，是区块链上加强隐私保护的常用手段。其将一次交易的来源（即输入地址）隐藏到多个合法的输入地址组成的集合当中，并为此来源确实属于此集合提供证明，从而达到减弱链上数据与某个交易单之间的直接联系的目的。

> 匿名通信机制基本思想可表达为：
>
> $C_M(Z_1,C_A(Z_0,m),A)\rightarrow C_A(Z_0,m),A$  
>
> 式子左侧为发送方法给中间人的信息，右侧为接受者从中间人获取的信息。发送方先用中间人的公钥 $C_M$ 对内容加密，然后发送给中间人。在发送过程中，即使内容被截获也不能解密。中间人收到信息后使用自己的私钥对内容解密，能够得到 $Z_1,C_A(Z_0,m),A$。其中，$Z_1$ 用于保证传送信息的准确性，中间人验证合法后丢弃此参数。$C_A(Z_0,m)$ 是用发送方的密钥加密后的内容，$A$ 为通信目的地址。消息内容 $m$ 和完整性凭证 $Z_0$ 使用接收方的公钥 $C_A$ 加密。因此中间方将加密后的内容发送至目的地址，此过程中间人无法获取消息内容。接收方收到后可通过自己的私钥解密得到消息 $m$，且通过 $Z_0$ 验证消息是否被篡改。

混币方案有中心化混币和去中心化混币两种实现机制。

中心化混币机制简单描述如下：若 A 需要向 B 支付数字货币，则 A 首先将对应金额支付给中心机构 C，之后 B 再向 C 索取对应金额。若 C 的业务量足够大，则单从区块链上记录的数据很难分析出 B 收到的数字货币具体来源于哪个地址。目前有许多网站提供混币服务，比如 [Bitcoin Fog](https://bitcoinfog.info/)、[Blockchain.info](https://blockchain.info/) 等。

但此朴素的实现方案存在许多安全隐患，首先混币机构 C 可能会拒绝将货币支付给 B。因此为了保证交易参与者的诚实执行，此类混币机制通常是基于智能合约完成。其次，A 对 B 的支付过程对 C 来说是完全透明的。首先实现中心化混币的 [Mixcoin](https://eprint.iacr.org/2014/077.pdf) 就没有考虑到这一点，因此无法抵挡恶意混币机构的攻击。因而，为了使支付过程对混币机构匿名，还需在此方案上加入盲签名技术。最后，为了达到隐藏支付者身份的目的，混币机构会选择多次交易或者保证参与混币的交易金额相等，因此会产生额外的交易延迟和交易费用。

去中心化的混币方法则不需要第三方节点实现混币操作，可分为需要多方同步参与的方案和不需要多方同步参与的方案。最早由 Gregory 提出的 [CoinJoin](https://bitcointalk.org/index.php?topic=321228) 机制，其核心思想便是将多个交易合并，构造一个多输入 - 多输出的交易，增加攻击者的攻击难度，属于多方同步参与的混币机制代表。此外还有 [Dark Wallet](https://www.investopedia.com/terms/d/dark-wallet.asp)、[CoinShuffle](https://cashshuffle.com/) 和 [JoinMarket](https://en.bitcoin.it/wiki/JoinMarket) 等均运用了这一思想。

但多方同步的方案需要混币用户自行协商执行，因此可能存在许多潜在的隐患：

1. 混币过程中，各个参与方可能知道其他输入输出的连接关系
2. 部分节点如果违规操作，会导致混币失败，这为攻击者提供了实现拒绝服务攻击的可能性
3. 混币构造的多输入 - 多输出交易最后会公布到区块链，因此用户无法否认曾参与混币的事实，隐私性降低
4. 可能从交易金额的联系获知输入与输出的关系

无需多方同步参与的去中心化混币方案则没有将所有参与混币的输入全部使用，而是将真实的输入包含在此集合中。方案为每一地址生成属于该集合的合法证明以及为了避免双重花费生成的唯一标识。从具体的交易单上无法看出是哪一个输入被使用，从而达到混币的目的。此类方案多使用环签名实现，上文提到的 CryptoNote 协议就是典型代表。

*应用实例*

[Blindcoin](https://link.springer.com/chapter/10.1007%2F978-3-662-48051-9_9) 是第一个使用盲签名技术对中心化混币机制进行改造的方案。下面介绍其具体方案：

> **STEP 1** 支付者 A 向混币机构 M 发送请求 $(D, [T]_{A_C} ), \ T = (k_{out}, n)$
>
> 含义：
>
> $D$：混币参数 $ \{t_1, t_2, t_3, t_4, v, \omega, ρ\} $
>
> $t_1, t_2, t_3, t_4$ ：时间参数
>
> $v$ ：交易金额
>
> $\rho$：支付者愿意承担的混币费用
>
> $\omega$：确认 A 的支付需要的区块数量
>
> $[T]$：盲化的凭证 $T$
>
> 凭证 $T$ 包含接收者地址 $k_{out}$ 和一个秘密随机数$n$；$n$ 用于计算混币费用
>
> 盲化的凭证 $[T]$ 用 A 的秘密承诺函数 $A_C$ 加密

> **STEP 2** 接受请求后，混币机构向支付者返回部分保证 $ \{[T]_{A_C} , k_{esc}, D\}_{M_{priv}}$
>
> 含义：
>
> $k_{esc}$：代理地址，供支付者支付货币；为每一位支付者生成唯一的地址
>
> 此部分保证需要用混币机构的私钥 $M_{priv}$ 加密
>
> 若混币机构拒绝请求，则支付者毁掉 $k_{out}$ 

> **STEP 3** $t_1$ 时间内，支付者向代理地址 $k_{esc}$ 支付货币 $v$；
>
> 若超时未支付，支付者和混币机构均退出此次混币

> **STEP 4** 混币机构补充完整保证
>
> 即：$t_2$ 时间内，混币机构用私钥 $M_{priv}$ 对盲化凭证 $[T]$ 签名，并将签名后的凭证 $\{[T]_{A_C}\}_{M_{priv}}$公布至公共日志中
>
> 若超时未发布，支付者可凭之前收到的部分保证 $ \{[T]_{A_C} , k_{esc}, D\}_{M_{priv}}$ 向任意第三方申请仲裁
>
> $t_2$ 应足够长，使得从 $t_1$ 开始计算交易深度达到 $\omega$ 个区块

> **STEP 5** 支付者匿名地取出目标地址
>
> $t_3$ 时间内，支付者对 $\{[T]_{A_C}\}_{M_{priv}}$ 计算 $A_C'$，取出 $\{T\}_{M_{priv}}=\{k_{out}, n\}_{M_{priv}}$
>
> 之后用户以用户 $A’$ 匿名登录，将 $\{T\}_{M_{priv}}=\{k_{out}, n\}_{M_{priv}}$ 发布至公共日志
>
> 若超时未发布，混币机构可选择将货币保留或退还

> **STEP 6** 混币机构通过 $Beacon$ 函数计算混币手续费
>
> 对每一对 $(k_{out},n)$ 计算 $Beacon(t_3,\omega,n)$
>
> 若计算指标小于等于支付者会支付的费用 $\rho$，则混币机构保留货币；
>
> 若计算指标大于 $\rho$，则进行下一步

> **STEP 7** 混币机构向目标地址支付货币
>
> $t_4$ 时间内，混币机构向 $k_{out}$ 支付 $v$ 个 BTC
>
> 若超时未支付，支付者可凭以下证据向任意第三方申请仲裁：
>
> > 承诺函数 $A_C,A_C'$，部分保证 $ \{[T]_{A_C} , k_{esc}, D\}_{M_{priv}}$，向代理地址转账记录 $Transfer(v,k_{in},k_{esc})$，混币机构签名的 $\{T\}_{M_{priv}}=\{k_{out}, n\}_{M_{priv}}$，以及 $t_4$ 时间内区块链上无代理地址向目标地址转账记录的事实

此方案主要通过发送盲化凭证的方式，使得混币机构无法对支付地址与接收地址进行配对，且设计了有效的防止混币机构盗窃货币的方案，有效降低了混币机构作恶的风险。

#### 2.1.2 环签名

**环签名的基本定义**

环签名的概念于 2001 年由 Ron Rivest，Adi Shamir 和 Yael Tauman 首次提出。此方案使得一组织中任意成员可用自己的私钥和其他成员的公钥进行签名，且无需管理员。所有人均可以验证该签名来源于此组织，但无法确认签名来源于某个具体的成员。这使得签名过程不可追踪，极大程度上保护了签名者的隐私。

通过在基本的环签名方案上进行改造，研究人员为其增加了可链接性、可追溯性等特点，因此出现了门限环签名、可链接环签名、可追溯环签名等不同的方案。

**环签名在区块链中的应用**

环签名隐私性高的特点对解决区块链隐私保护的问题具有重大意义。许多项目均试图采用环签名技术来解决这一问题。

**CryptoNote 协议**

[CryptoNote](https://cryptonote.org/whitepaper.pdf) 是在 Bitcoin Core 协议的基础上，采用了多种密码学技术对其进行了多方面改进的新加密货币协议。最早由 Nicolas van Saberhagen 提出。其中该系统采用了基于可追溯环签名的技术对 Bitcoin 协议进行了隐私性方面的改进。

**签名算法**

CryptoNote 的环签名设计基于 E. Fujisaki and K. Suzuki  提出的 [可追溯环签名方案](https://link.springer.com/chapter/10.1007/978-3-540-71677-8_13)，并将其中的可追溯性弱化为可链接性。方案中的基本签名算法为快速 EdDSA 算法，因而包含了以下基本的椭圆曲线参数：

$q$ 为质数，这里 $q = 2^{255} − 19$

$d\in\mathbb{F}_q$，这里 $d = −121665/121666$

$E$ 为有限域上的椭圆曲线 $−x^2 + y^2 = 1 + dx^2y^2$ 

$G\in E$ 为椭圆曲线上的基点，这里 $G = (x, −4/5)$

$l$ 为基点的阶，这里 $l = 2^{252} + 27742317777372353535851937790883648493$

$\mathcal{H}_s:\{0, 1\}^ ∗ → \mathbb{F}_q$ 为密码学杂凑函数

$\mathcal{H}_p: E(\mathbb{F}_q) \rightarrow E(\mathbb{F}_q)$ 为确定性杂凑函数

> $KeyGen$：
>
> **输入**：参数组 $(q,d,E,G,l)$
>
> **输出**：单用户密钥对 $(P,x)$，公钥映像  $I$
>
> 1. 每个用户产生（伪）随机数 $x\stackrel{\$}\longleftarrow[1，l-1]$ 作为临时签名私钥
> 2. 每个用户计算 $P=xG$ 作为公钥
> 3. 计算公钥映像 $I=x\mathcal{H}_p(P)$
> 4. 返回单用户密钥对 $(P,x)$，环公钥  $I$

> $Sign$：
>
> **输入**：参数组  $(q,d,E,G,l)$，消息 $m$ ，签名者密钥对 $(P_s,x_s)$，非签名者公钥列表的子集 $\mathcal{S}'=\{P_i\}_{i\ne s}^n$
>
> **输出**： 签名 $ \sigma $，公钥列表 $\mathcal{S}=\mathcal{S}'\bigcup \{P_s\}$
>
> 1. 签名者从其他用户的公钥列表中随机选择一个大小为 $n$ 的子集 $\mathcal{S}'$
>
> 2. 签名者生成（伪）随机数数列 $ \{q_i \in(1 . . . l)| i = 0 . . . n\} , \{w_i\in(1 . . . l) | i = 0 . . . n, i \ne s\}$
>
> 3. 签名者计算  $\forall \ i\in[0,n]$
>
> $$
> L_i=\left\{
> \begin{array}\\
> q_iG,\quad\quad \quad \quad i=s\\
> q_iG+w_iP_i,\quad\ i\ne s 
> \end{array}
> \right.
> $$
>
> $$
> R_i=\left\{
> \begin{array}\\
> q_i\mathcal{H}_p(P_i),\quad\quad \quad \quad i=s\\
> q_i\mathcal{H}_p(P_i)+w_iI,\quad\ i\ne s 
> \end{array}
> \right.
> $$
>
> 4. 计算挑战 $c=\mathcal{H}_s(m,L_1,...,L_n,R_1,...,R_n)$
>
> 5. 计算回应 
>
> $$
> c_i=\left\{
> \begin{array}\\
> w_i,\quad\quad \quad \quad i=s\\
> c-\sum_{i=0}^nc_i\ \ mod\ \ l,\quad\ i\ne s 
> \end{array}
> \right.
> $$
>
> $$
> r_i=\left\{
> \begin{array}\\
> q_i,\quad\quad \quad \quad i=s\\
> q_s-c_sx\ \ mod\ \ l,\quad\ i\ne s 
> \end{array}
> \right.
> $$
>
> 6. 计算签名 $\sigma=(I,c_1,...c_n,r_1,...,r_n)$
>
> 7. 返回签名 $ \sigma $，公钥列表 $\mathcal{S}=\mathcal{S}'\bigcup \{P_s\}$

> $Verify$：
>
> **输入**：参数组  $(q,d,E,G,l)$，消息 $m$ ，公钥列表 $\mathcal{S}$
>
> **输出**：1（签名通过验证），0（签名未通过验证）
>
> 1. 验证者计算 $\forall \ i\in[0,n]$　
>
> $$
> \left\{
> \begin{array}\\
> L_i'=r_iG+c_iP_i\\
> R_i'=r_i\mathcal{H}_p(P_i)+c_iI 
> \end{array}
> \right.
> $$
>
> 2. 验证者判断 $\sum_{1=0}^n\stackrel{?}=\mathcal{H}_s(m,L_0',...,L_n',R_0',...R_n')\ \ mod\ \ l$
>
> 3. 若等式成立，返回 1，并运行 $Link$ 算法；否则返回 0 并拒绝签名

> $Link$：
>
> **输入**：公钥映像集合 $\mathcal{I}=\{I_i\}$，签名 $\sigma$
>
> **输出**：1（链接），0（未链接）
>
> 1. 验证者检查 $I\stackrel{?}\in \mathcal{I}$，即检查 $I$ 是否被使用过
> 2. 若使用过多次则表示有两个签名由同一私钥生成，返回 1
> 3. 否则返回 0

**实例**

[CryptoNote](https://cryptonote.org/)、 [Bytecoin](https://bytecoin.org/) 、 [Boolberry](https://boolberry.com/) 、[Monero](https://www.getmonero.org/)、[AEON](https://aeon.co/) 、[Fantomcoin](http://fantomcoin.org/) 等加密货币均基于 CryptoNote 协议设计。以太坊也加入了 CryptoNote 类。

**评价**

此协议通过环签名技术为用户提供了无法追踪的付款方式，保证了支付用户的隐私性。另外系统使用 Diffie - Hellman 交换协议，为每个公钥派生出多个唯一的一次性地址，使得交易无法被交叉追踪，保证了接收方的隐私。此外，方案中使用密钥镜像的设计使得双重花费的试图被有效阻止。但使用此协议必须保证参与的交易金额相同，且存在此交易金额可见的问题。

*参考代码*

https://github.com/cryptonotefoundation/cryptonote 

**Monero 对 CryptoNote 协议的改进**

为了解决 CryptoNote 中交易金额可见的问题，[Monero](https://www.getmonero.org/) 提出了 [RingCT][ https://eprint.iacr.org/2015/1098.pdf ] 环状签名保密交易协议。协议使用了 [Pedersen 承诺](https://www.getmonero.org/resources/moneropedia/pedersen-commitment.html)，使得新产生的 Monero 在第一次发生转移时，产生带有金额遮罩的 RingCT 交易输出。因此 Monero 在执行混币操作时可以任意选择一个输出，而无需对金额进行切分，因而大幅提高了匿名性。在此后的 [2.0][ https://allquantor.at/blockchainbib/pdf/sun2017ringct.pdf ] 版本中，Monero 对 1.0 版本进行了规范化并加入了基于双线性对的累加器，对签名大小和运行效率做出了优化。近期发布的 [RingCT 3.0][ https://eprint.iacr.org/2019/508.pdf ] 方案去除了 2.0 版本中的可信设置假设，提高了系统的安全性；并采用了基于 Bulletproofs 的全新方式计算身份证明，使得身份证明大小由 $O(Mlog(n))$ 降为 $O(M+log(n))$（ $M$ 个交易输入、总 $n$ 个公钥）。新方案在典型的 2 输入交易场景下可将签名大小较 1.0 版本减少 98%。

#### 2.1.3 群签名

**群签名的基本含义**
群签名的概念是由 Chaum 和 Heyst 于 1991 年提出的。群签名方案中，一个群体中的任意一个成员可以以匿名的方式代表整个群体对消息进行签名。外界可以验证其合法性，即此签名的确为此群体中的某人生成，但不能确定到底是哪位成员，保护了成员的隐私。在发生争议的情况下，可由一具有特权的群管理员“打开”争议的签名找出真正的签名者，因此带来了可追踪的特性。
**群签名算法思路**
一般情况下，一个群签名方案应包含以下六个多项式时间算法：

* Setup：给定安全参数 K，群管理员（GM） 生成一个群公钥（GPK）可用于群签名的验证，以及一个群私钥（GSK）可用于生成成员证书以及签名打开。
* Join：一个用户和群管理者之间的使用户成为群成员的交互式协议，一旦执行该协议后可产生群成员的私钥和成员证书，并使群管理者得到群成员的秘密的成员管理钥。对于静态的群签名，GM 直接生成成员证书，没有交互过程，缺点是 GM 可冒充成员签名。
* Sign：输入一个消息和一个群成员的私钥后，能得出对消息的签名。
* Verify：任何人获得 GPK 和一个消息签名，通过该算法可验证对消息的签名是否有效。
* Open：GM 通过该算法可确定对某一合法群签名，其签名者身份是否有效。
* Revoke：GM 可撤销某成员的签名权利。

**安全性要求**

* 完整性： 群成员的有效签名始终验证正确，无效签名则始终验证失败。
* 不可伪造性： 只有群成员才能创建有效的群签名。
* 匿名性： 给定一个群签名后，如果没有群管理员的密钥，则无法确定签名者的身份，至少在计算上是不可行的。
* 可跟踪性： 给定任何有效的签名，群管理员应该能够确定签名者的身份。
* 不关联性： 给定两个消息及其签名，我们无法判断签名是否来自同一签名者。
* 无框架： 即使所有其他群成员相互串通（包括和管理员串通），他们也不能为非群成员伪造签名。
* 不可伪造的跟踪验证： 管理员不能错误地指责签名者创建了他本没有创建的签名。
* 抗合谋攻击： 即使所有群成员相互串通，他们也不能产生一个合法的不能被跟踪的群签名。

**群签名典型构建**
[Ateniese G](http://www.ics.uci.edu/~gts/paps/acjt00.pdf) 等在 2000 年在 ROM ( random oracle model) 模型下构建了群签名方案。方案中利用了基于知识签名的技术，实现了群公钥和签名的长度、计算复杂度均与群大小独立；有新成员加入时，群公钥保持不变；以及可以隐藏群的大小。方案在 strong RSA 假设下实现了较高的安全性。
[Boyen](http://www.cyber-ta.org/pubs/waters-full-domain-pkc07grp.pdf) 等在 BW07 方案中，提出了在标准模型下基于层次签名的群签名方案。此构建方法使用两种签名方案：GM 使用一种方案签名作为给群成员的证书，群成员利用此证书使用另一种签名方案进行签名。随后使用承诺方案对此签名进行随机化，且使用非交互式零知识证明系统证明其合法性。群管理员具有打开证明系统内容的密钥，因而实现了可追踪性。
[Gordon](https://eprint.iacr.org/2011/060.pdf) 等在 ROM 模型下基于格中的 LWE(learning with errors) 困难问题实现了可抗量子攻击的群签名方案。

[Vicente](https://eprint.iacr.org/2008/047.pdf) 等在 ROM 模型下提出了公平可追踪的多群体签名方案。方案可使多群体的个公平管理者在独立管理的情况下，合作完成对可疑签名的打开；也可以公布某个可疑用户的追踪密钥，同时不泄露其他用户的隐私。

**群签名在区块链中的应用**

群签名结合了匿名性和可监管性，在区块链隐私保护中也得到了应用。在区块链中的群签名一般要具有可链接的性质。比如 [Orbs](https://www.orbs.com/) 团队原创设计的共识协议 [Helix]( https://www.orbs.com/white-papers/helix-consensus-whitepaper/ ) 中运用了可链接的群签名，该协议根据相对声誉的比例选择节点参与委员会，因而需要一种机制来揭示哪些网络节点负责有问题的交易，以降低其声誉。因此该协议使用了具有分布式追踪性的群签名来达到这一目的，即让每个网络节点都充当公平性机构，并要求一定阈值数量的机构来打开和追踪签名。  

[Juzix](https://www.juzix.net/) 开发的 JUICE 开放服务平台通过集成广播加密和群签名，实现交易请求节点能在以匿名方式保护身份隐私的同时支持管理节点审查，并可指定多个接收方查看加密的内容，大幅提升了交易的隐私性、可追溯性和灵活性。 

*参考代码*

[libgroupsig](https://bitbucket.org/jdiazvico/libgroupsig/wiki/Home) 

#### 2.1.4 多重签名

**多重签名的基本含义**

在通常情况下，许多加密货币例如 Bitcoin 等均使用标准的单密钥地址保存资金。这使得任何人只需拥有私钥就能够直接访问该笔资金且签署交易。可见，单一密钥的管理体系虽然在系统设计上显得更加简单，但也带来了严重的安全风险。一旦密钥泄露，资金就可在无授权的情况下被转移。

此外，区块链上一些重要的功能应用，例如 [跨链原子交换](https://en.bitcoin.it/wiki/Atomic_swap)、[闪电支付通道](https://en.bitcoin.it/wiki/Lightning_Network) 等都需要多重签名技术来完成比现有方案更简洁隐私的实现。

因此，多重签名技术在区块链领域被广泛讨论。多重签名（M - N 签名）早在加密货币出现之前就已出现，方案规定被签名的消息与 N 个密钥绑定，必须提供至少 M 个私钥才能解锁消息。最常见的就是三分之二（2 / 3）方案，即需要提供 2 个起私钥就可以访问地址中的资金。这样的设计通过分散风险使得单一密钥丢失或被盗引起的风险降低。

在 2018 年的亚密会上，Boneh 等人提出一种适合区块链的更加紧凑的多重签名方案 [Compact Multi-signatures for Smaller Blockchains](https://eprint.iacr.org/2018/483.pdf )。

**多重签名在区块链中的应用**

目前已有多个区块链项目以不同的手段支持了多重签名方案。

**Monero 门罗币**

Monero 门罗币利用密码学中的 [秘密分享](https://en.wikipedia.org/wiki/Secret_sharing) 模拟实现了这一功能。门罗币允许多个用户共同拥有一个钱包，多重签名的功能在钱包层面实现；而区块链上的数据不会表征此交易是否应用了多重签名。在其方案中，一笔交易仍使用单个支出密钥进行签名，但消费时所需的密钥是所有 N 个私钥的总和。例如在 2 / 3 方案中，共有 3 位参与者，那么每个参与者将正好被授予 2 个私钥，以使参与者之间不会重复配对。这样，任何 2 个参与者在一起就拥有创建消费私钥所需的全部 3 个私钥。密钥的共享需要使用者们在安全信道内手动进行，钱包本身是不提供安全信道的。当前，Monero 仅支持 N / N 和 N - 1 / N 方案。 

**Bitcoin**

Bitcoin 则通过脚本实现这一功能。以太坊的多重签名钱包也采用了类似的设计，只不过是依靠智能合约来实现。Bitcoin 最多支持 15 个私钥参与签名，即 $1\le M\le N\le15$。方案简述如下：首先由 $N$ 个用户的 $N$ 个公钥构造赎回脚本，并同时各自保管一个完整的赎回脚本。对此赎回脚本计算哈希值并使用 Base58check 编码后，即可得到一个 P2SH 类型的地址，作为此多重签名的联合地址。若要向此地址转入资金，只需提供输入 UTXO 的交易 ID、资金来源方的私钥、转入金额以及此联合地址，与转入普通 Bitcoin 地址无明显区别。若要使用此地址中的资金，则需要提供 UTXO 的交易 ID、花费数额、至少 $M$ 个私钥（用于生成签名）以及完整的赎回脚本。注意这里私钥的输入顺序应当保持与写入赎回脚本中公钥的顺序一致。

基于这样的设计，便可以成功实现多重签名的功能。然而，这样的方案仍然存在许多弊端：比如每一位用户在花费资金前都必须保存完整脚本，花费较高。另外，此方案使得单笔交易中一定包含多个显式的签名。这不仅极大地增加了交易数据的规模，导致交易费用增加；更可能由此导致此交易引起不必要的注意，增加了隐私泄露的风险。并且，依靠脚本和合约实现很容易遭受由脚本运行出错带来的损失，比如以太坊的多重签名钱包 [Parity](https://www.parity.io/the-multi-sig-hack-a-postmortem/) 就曾于 2017 年 7 月因为漏洞被黑客利用，造成了多个项目共 15 万以太币被盗走。

因此，一些改进的多重签名方案被陆续提出，主要试图从加密层使用密码学工具来实现多重签名的目的。其中上文提到的 Schnorr 签名方案因其支持签名聚合等良好特性，成为了解决这一问题的新手段。 

**MuSig**

BlockStream 团队提出的 [MuSig](https://blockstream.com/2019/02/18/en-musig-a-new-multisignature-standard/) 项目，使用 Schnorr 签名定义了新的多重签名方案。具体算法如下：

算法涉及参数组 $ (\mathbb{G}, p, g)$，其中：

​	$p$ 为 k-bit 整数

​	$G$ 为 p 阶循环群

​	$g$ 为 $\mathbb{G}$ 的生成元

签名过程用到 $H_{com}, H_{agg}, H_{sig}: \{0, 1\}^*\rightarrow \{0, 1\} ^l$ 三个杂凑函数，$H_{com}$ 用于承诺阶段，$H_{agg}$ 用于计算聚合密钥，$H_{sig}$ 用于计算签名。

> $KeyGen$：
>
> **输入**：参数组 $T(\mathbb{G},p,g)$
>
> **输出**：公钥列表 $L=\{pk_1 = X_1, . . . , pk_n = X_n\}$ ，当前用户密钥对 $(X_1,x_1)$ 
>
> 1. 每个用户产生（伪）随机数 $x\stackrel{\$}\longleftarrow\mathbb{Z}_p$ 作为临时签名私钥
> 2. 每个用户计算 $X=g^x$ 作为公钥
> 3. 返回公钥列表 $L=\{pk_1 = X_1, . . . , pk_n = X_n\}$  ，当前用户密钥对 $(X_1,x_1)$ 

> $Sign$：
>
> **输入**：参数组 $T(\mathbb{G},p,g)$，消息 $m$ 和公钥列表 $L=\{pk_1 = X_1, . . . , pk_n = X_n\}$ ，当前用户密钥对 $(X_1,x_1)$
>
> **输出**： 签名 $ (R,s) $
>
> 1. 所有用户计算 $a_i=H_{agg}(L,X_i)$
> 2. 计算聚合公钥 $\widetilde{X}=\prod_{i=1}^nX_i^{a_i}$
> 3. 当前签名者产生（伪）随机数 $ r_1\stackrel{\$}\longleftarrow\mathbb{Z}_p$ 
> 4. 当前签名者计算 $R_1=g^{r_1},t_1=H_{com}(R_1)$，并将 $t_1$ 广播给其他签名者
> 5. 待当前签名者收到其他签名者发送的承诺 $t_2,...t_n$ 后，再将 $R_1$ 发送给其他签名者
> 6. 待当前签名者收到其他签名者发送的 $R_2,...R_n$ 后，检验$t_i=H_{com}(R_i)$ 对 $i\in \{2,...,n\}$ 均成立
> 7. 若不成立，则退出签名过程 
> 8. 若成立，计算 $R=\prod_{i=1}^nR_i$，$c=H_{sig}(\widetilde X,R,m)$，$s_1=r_1+ca_1x_1\ \ mod\ \ p$ ，并将 $s_1$ 发送给其他签名者
> 9. 待当前签名者收到其他签名者发送的 $s_2,...s_n$ 后，计算 $s=\prod_{i=1}^ns_i\ \ mod\ \ p$
> 10. 返回签名 $(R,s)$

> $Verify$：
>
> **输入**：参数组 $T(\mathbb{G},p,g)$，消息 $m$ 和公钥列表 $L=\{pk_1 = X_1, . . . , pk_n = X_n\}$ ，签名 $ (R,s) $
>
> **输出**：1（签名通过验证），0（签名未通过验证）
>
> 1. 对 $i\in\{1,...,n\}$，计算 $a_i=H_{agg}(L,X_i)$
> 2. 计算 $\widetilde{X}=\prod_{i=1}^nX_i^{a_i}$
> 3. 计算 $c=H_{sig}(\widetilde{X},R,m)$
> 4. 判断等式 $g^s=R\prod_{i=1}^n X_i^{a_i c}=R \widetilde{X}^c$是否成立
> 5. 如果等式成立，返回 1；否则返回 0

此方案可以与 Bitcoin 所采用的 sepc256k1 曲线兼容，其代码已经兼并在 secp256k1-zkp 密码库中。与此前的多重签名方案相比，此方案有许多独特的优点：

首先，无论签名者如何设置，签名的大小都是简短恒定的。而验证效率恰好是区块链中最重要的考虑因素之一。这也让签名者的具体策略得以很好地隐藏。

其次，此方案拥有普通公钥模型中的可证明安全性。这使得签名者无需提供关于密钥生成和管理的额外信息，极大提高了签名者的灵活性。

*多重签名的参考代码*

 https://github.com/soroushjp/go-bitcoin-multisig 

 https://github.com/ElementsProject/secp256k1-zkp/tree/secp256k1-zkp/src/modules/musig 

 https://github.com/KZen-networks/multi-party-schnorr 

#### 2.1.5 聚合签名

**聚合签名的定义和性质**

聚合签名是一种具有附加性质的数字签名，能够将多个不同的签名者产生的多个签名聚合成一个较短的签名（理想情况下聚合签名的长度等于单个签名的长度），验证者只需要验证这个聚合签名而无需验证所有的单个签名。需要注意的是，聚合签名与多重签名补充的地方在于，前者是对多个不同消息的签名进行聚合，而后者是多个签名者对同一个消息进行签名。聚合签名能够有效的节省签名的传输和存储的代价，是一个应用范围比较广、实用价值比较高的签名。聚合签名可以分为非时序聚合签名 (AS) 和时序聚合签名（SAS），前者一般需要一个可信第三方对多个签名者产生的签名进行聚合，后者要求不同的签名者按顺序对签名进行聚合。

聚合签名可以基于 RSA 假设、双线性映射、格等数学结构进行构造。

**聚合签名在区块链中的应用**

- 聚合签名可以用于设计隐私币，例如在 [Mimblewimble]( https://link.springer.com/chapter/10.1007/978-3-030-17653-2_22 ) 中，聚合签名和承诺协议、零知识协议等技术一起用于增强交易隐私；
- 在一些区块链混合共识的设计（例如 [OmniLedger]( https://eprint.iacr.org/2017/406.pdf )）中，需要由选举出的 leader 组织通过 BFT 共识将一些关键信息倍数到区块链上，使用聚合签名可以优化背书过程的通信复杂度 （例如中 [OmniLedger]( https://eprint.iacr.org/2017/406.pdf ) 使用的 [CoSi signing](  https://arxiv.org/pdf/1503.08768.pdf )）；此外，聚合签名可以用于减少区块链系统中的签名数据传输代价。

#### 2.1.6 门限签名

**门限签名的基本定义**

门限签名，即 Threshold Signature Scheme (TSS)，是 [门限秘密分享技术][http://dx.doi.org/10.1145/359168.359176 ] 和数字签名的结合。Desmedt Frankel 于 1991 年提出了 [(t,n) - 门限签名方案](https://link.springer.com/chapter/10.1007/3-540-46766-1_37)。(t,n) - 门限签名方案中，n 个成员组成一个签名群体，此群体有一对公钥和私钥；群体内至少 t 个合法诚实成员的组合可以代表此群体用群私钥进行签名，且任何人可利用该群体的公钥进行签名验证。这里 t 是门限值（Threshold），表示合法成员数量达到此阈值后方可代表群体签名，且群体中任何成员均无法假冒其他人参与签名。门限签名可以实现权力分配，避免滥用职权。

根据秘密分配的方式，可将门限签名方案分为有可信中心门限签名方案和无可信中心的门限签名方案。在实际应用中，无可信中心的方案应用更为广泛。门限签名一般包含以下三个多项式时间算法：

- $KeyGen$：所有成员获得相同的公钥和私钥的秘密份额。
- $Sign$：输入一笔交易和至少 t 个秘密份额，输出 1 个有效的签名。 
- $Verify$：输入群公钥和签名，当签名成功通过验证时输出 1，否则输出 0。

*门限签名与多重签名的异同*

这里以 MuSig 为代表与门限签名方案作比较。

<table> 
                               门限签名与多重签名的异同
  <tr><th>方案名称</th><th>密钥分配</th><th>签名过程</th><th>验证过程</th><th>评价</th></tr> 
  <tr><td>门限签名</td><td>所有成员保管一个相同的公钥和私钥的一份秘密份额</td><td>至少出示 t 个秘密份额，生成 1 个有效签名</td><td>使用共同公钥进行验证</td><td>秘密分割在客户端完成，成员个人信息保持匿名；仅包含一个签名，数据量小</td></tr>  
    <tr> <td>多重签名</td><td>所有成员独立生成自己的公私钥对，共同公钥由所有成员公钥计算得到</td><td>n 个成员全部参与；由 n 个私钥独立生成  n 个签名，再组合成 1 个签名</td><td> 使用聚合公钥进行验证</td><td>成员独立公钥为公开，隐私性差；成员增删需要重新计算公钥；包含 n 个签名，占据空间大</td></tr>
</table>

**门限签名在区块链中的应用**

TSS 可在 ECDSA，Schnorr 和 BLS 签名算法上实现（例如 [ZenGo](https://github.com/KZen-networks/) 或 [TSSKit](https://github.com/Turing-Chain/TSSKit-Threshold-Signature-Scheme-Toolkit)）。 ZenGo 移动客户端使用的是 2-2 门限签名方案，一份密钥保存在用户移动端，一份保存在 ZenGo 的服务器上。交易时必须同时出示两份密钥才能完成签名。Rosario Gennaro 于 2018 年提出了基于 ECDSA 实现的 TSS [方案](https://eprint.iacr.org/2019/114.pdf)，降低了计算复杂性且提高了签名效率。

代码可参考： https://github.com/KZen-networks/multi-party-ecdsa 



### 2.2 承诺和零知识证明协议

#### 2.2.1 承诺协议

承诺方案是一个两方协议，包括承诺者和接受者两个参与方，其中承诺者持有秘密消息。承诺方案包括两个阶段，即承诺阶段和打开阶段。在承诺阶段，承诺者以持有的秘密信息为输入，生成承诺值和陷门信息，再将承诺值发送给验证者；在打开阶段，承诺者将陷门信息和秘密信息都提供给验证者，验证者可以验证承诺值是对秘密信息的承诺。

承诺方案通常考虑两种安全性质：

- 隐藏性：指在不提供陷门信息的情况下，承诺值不会泄露秘密信息。根据考虑的攻击者计算能力差异，隐藏性可以分为计算隐藏性（Computational Hiding）——对计算能力有限的攻击者保持隐藏性，和统计隐藏性（Statistical Hiding）——对计算能力无限的攻击者仍然保持隐藏性。
- 绑定性：指承诺者无法针对一个承诺值提供两组陷门信息和秘密信息，并使其都可以通过验证。同样的，绑定性也可分为计算性绑定（Computational Binding）和统计性绑定（Statistical Binding）。

一个承诺方案不可能同时拥有统计隐藏性和统计绑定性。通常，承诺方案可以分为计算隐藏统计绑定的承诺方案和统计隐藏计算绑定的承诺方案。

承诺方案在区块链系统中最典型的应用是表示数字货币。由于承诺方案的隐藏性，数字货币不会泄露持有人的信息或者私钥信息。花费数字货币则需要持有人提供表示该数字货币的承诺值相应的秘密信息和陷门信息。承诺方案在区块链中的应用不局限于表述数字货币，一切需要提前确定但不希望立即揭示的信息，都可以通过承诺方案来完成。 基于区块链的拍卖系统等场景也依赖于承诺方案得以实现。

目前在区块链系统中使用的承诺方案有两种实现方式，包括基于杂凑函数的实现和基于离散对数的实现。前者通常使用标准的 SHA256 函数，在承诺阶段首先选取随机字符串 $r$，对待承诺的消息 $m$ 计算 $SHA256(m||r)$ 作为承诺值；后者通常使用 Pedersen 承诺方案，即选取素数阶群 $G$ 的两个生成元 $g$ 和 $h$ 作为公开参数，对承诺的消息 $m$ 首先选取随机数 $r$，计算承诺值 $g^mh^r$。前者通常易于实现，更为高效，但缺乏代数结构，难以设计相应的协议。后者计算效率略低，但具有素数阶群的代数结构，有利于设计高效的密码协议。

**同态承诺方案**

Pedersen 承诺方案是一种统计隐藏计算绑定的承诺方案，还额外满足一种叫做加同态的性质，因而被称作是同态承诺方案。加同态性质是指对于两个承诺值 $c_1$ 和 $c_2$，其对应的秘密信息和陷门信息为 $(m_1,r_1)$ 和 $(m_2,r_2)$，那么对于 $c_1*c_2$ （$*$表示群中的运算），其对应的秘密信息和陷门信息为 $(m_1+m_2,r_1+r_2)$。利用加同态性质，可以在不知晓被承诺秘密信息的前提下生成新的承诺值。这一性质在数字货币系统中的交易金额隐私保护上有较好的应用。

为了保护用户隐私，承诺者通常使用**零知识证明协议**来证明其持有对应承诺值的秘密信息和陷门信息，而不是直接将其公开。

#### 2.2.2 零知识证明协议

零知识证明是一种两方的密码协议，包括证明者和验证者两个参与方，其中证明者持有秘密信息。证明者所要证明的关系通常表示为一种 NP 关系 $L$，对于某一字符串 $x$，证明者知道对应的证据 $w$，使得 $x\in L$可以被公开验证。对于一个零知识证明协议，通常考虑一下三点性质：

- 完备性：对于诚实的证明者和验证者，如果 $x\in L$ 且 $w$ 是其证据，则验证者总会接受证明者提供的证明。
- 可靠性：对于 $x \notin L$，任何（有限计算能力的）证明者都不能使验证者接受证明。
- 零知识性：验证者无法通过证明获取除了 $x\in L$ 之外的任何信息。

其中，若可靠性考虑的是具有有限计算能力的证明者，则该协议被称为零知识论证协议（Zero-knowledge Argument）。在某些情况下，零知识证明协议也会考虑一种被称为知识证明（Proof of Knowledge）的性质。这一性质实际上是可靠性的一种特殊定义，即若证明者可以对 $x\in L$ 做出正确的证明，则其必然知道对应的证据 $w$。

目前区块链系统中部署的零知识证明协议主要为非交互式零知识证明协议，即协议仅包含证明和验证两个阶段。证明者可以独立作出证明，而任意验证者可以离线地验证一个正确的证明。

从协议的功能划分，区块链系统中常用的零知识证明协议主要包括以下两类：

1. 身份证明协议（Proof of Identity）：证明者通过此类协议证明自己知道某个承诺值对应的秘密信息。通常承诺值可以作为该证明者的公钥，而知晓承诺值的秘密信息意味着该公钥确实属于证明者，因此此类协议被称为身份证明协议。在区块链系统中，身份证明协议通常被用于证明己方拥有对某个数字货币的所有权。数字签名也可以看做是一种非交互的身份证明协议。
2. 成员关系证明（Proof of Membership）：证明者不再证明其所知晓的秘密消息对应到某个具体的承诺值，而是证明该承诺值（或秘密消息）属于某个公开的集合。在区块链系统中，成员关系证明是增强用户隐私的重要协议：支付者不再需要在交易单中明确自己所花费的数字货币，而是列出多个数字货币，再通过成员关系证明自己拥有其中的某个数字货币。从而交易单上不再体现交易单的关联性，避免了交易关系图的分析。此外，当证明者试图证明的公开集合是一个范围内的所有值时，此类证明也被称为范围证明（Proof of Range）。在区块链系统中，范围证明在设计保护交易金额的协议中有重要应用。

从协议的设计来划分，零知识证明协议可以分为针对特定 NP 关系的协议以及针对通用电路的协议两类。在区块链系统中，涉及到的特定 NP 关系主要包括基于离散对数问题表述的身份证明、范围证明等对应的关系。针对通用电路的协议实际上是对以下关系的证明：令 $C$ 是多项式大小的电路，证明者需要证明存在一组输入 $x$，使得 $C(x)=0$。由于任何多项式时间内能验证的关系都可以转换为多项式大小的电路，因此在使用针对通用电路的协议时，证明者不再需要考虑需要证明的特定关系，只需要将待证明的关系用电路表示，再证明存在一组输入使得这个电路的输出值为 0 即可。

*零知识证明协议在区块链中的应用*

在区块链中，应用零知识证明协议可以做到不暴露转账金额转账地址的情况下，验证者可以进行验证。因此使用零知识证明可以做在区块链上达到良好的匿名性。

目前区块链系统中，面向特定 NP 关系的零知识证明协议基于离散对数问题实现，是在经典的 Schnorr 协议上发展扩充而来，并使用 Fiat-Shamir 转化使之转变为非交互式的零知识证明协议。同时，因为使用了 Fiat-Shamir 转换，这一类零知识证明协议的安全性是建立在随机预言机模型上的。

面向通用电路的零知识证明协议通常比面向特定关系的协议效率要低，在区块链系统中，证明通常需要向全网广播，并存储在区块链上供所有的节点验证。因此，缩减证明的大小对于提升区块链系统的效率由重大意义。具体而言，在区块链中主要涉及到的零知识证明主要有 *NIZK*，*zk-SNARKs*，*zk-STARKs*，*Bulletproofs* 等。

##### NIZK

NIZK（Non-interactive zero-knowledge proof）非交互式零知识证明是零知识证明的一种变体，其中证明者与验证者之间不需要交互。 Blum，Feldman和Micali表明，在证明者和验证者之间共享的公共参考字符串足以在不需要交互的情况下实现计算零知识。

Zerocoin 首先提出使用 *NIZK* 协议。在该协议中验证者和证明者拥有相同的参考字串 D ，该字串由初始设置 $\sigma \leftarrow \operatorname{Setup}\left(1^{k}\right)$ 生成。 为证明 $y \in L$ 有着 w，证明者运行 $\pi \leftarrow \operatorname{Prove}(\sigma,y,w)$  并将证据 $\pi$ 发送给验证者。当 $ \operatorname{Verify}(\sigma,y,w)=accept$ 验证者接受该证据，否则拒绝。
该协议证明参数量较大，在实际应用中较为困难。

非交互式零知识证明可以使用Fiat–Shamir启发式方法在随机预言模型中获得。[该文章](  http://dl.acm.org/citation.cfm?id=2090263 )引入 zk-SNARKs，实现了简介验证。
2017 年 [Bulletproofs](http://web.stanford.edu/~buenz/pubs/bulletproofs.pdf) 发布，它使用对数有限域和群来证明承诺值在范围内，进一步降低了证明大小。
在 2018 年，[该文章](https://eprint.iacr.org/2018/046.pdf)引入了 zk-STARKs 协议，该协议提供了透明度（无可信设置），准线性证明时间和多对数验证时间。  

##### zk-SNARKs

zk-SNARKS全称为零知识简洁非交互知识论证（Zero-knowledge Succinct Non-interactive Argument of Knowledge) zk-SNARKs。简洁性（Succinct）是指，证明的大小要显著小于使得的 $C(x)=0$ 的 $x$ 长度。  

*zk-SNARKs* 协议针对 *NIZK* 进行了改进，降低了参数数量 。*zk-SNARKs* 安全性是基于双线对中的困难问题。*zk-SNARKs* 采用 CRS 进行初始参数设置，依赖于一个可信的启动阶段。

[PGHR13](https://eprint.iacr.org/2013/279.pdf) 提出了 Pinocchio 协议，在此基础上，zk-SNARKS 协议主要分为以下几步： 

1. 首先将欲证明的论断转化为计算问题
2. 将该计算性问题，转换成算术电路
3. 将算术电路转换成 R1CS 形式问题。
4. 再将 R1CS 转变成 QAP 形式问题。
5. 基于 QAP 问题，结合 KCA、CRS 实现证明的生成以及验证。

目前使用 zk-SNARKs 的项目主要是 Zerocash 及其后续项目 Zcash。

##### Bulletproofs

*Bulletproofs* 可以略去初始参数设置，并进一步降低参数空间复杂度。Bulletproofs 改进了由 Bootle 等人提出的内积论证，利用离散对数关系来构建内积论证，将证明转化为证明 $P = g^ah^b$ 并且 $c=<a,b>$。通过将需要证明的向量不断二分 $n^,=n/2$，最终生成了大小为 $2\log_2n$ 的证据；BulletProofs 提出了多方计算协议，该协议允许具有秘密提交值的多方共同生成针对其所有值的单个范围证明。多方计算协议可被用于构造交易所需的所有证明，并聚合为单个简单证明；BulletProofs 可用于通用 NP 语言，证明大小与算术回路中的乘法门数量呈对数关系，原生支持 Peterson 承诺；BulletProofs 还可将改进后的内积论证用于范围证明，最终实现了具有对数大小的范围证明。并且在提出的范围证明中原生支持了 Peterson 承诺以及椭圆曲线。

MimbleWimble 协议中构建保密交易（Confidential Transaction）时，在对金额的部分，需要证明这个交易所有的输出里都没有负数。因此每个交易输出需要有一个 Range Proof，来证明所有的交易输出都小于某个阈值，且都是正的。这里使用了 BulletProofs 中构建的 Range Proof。

2018 年 10 月，门罗币（Monero）通过硬分叉迎来了重大升级——引入 BulletProofs，这项技术可以帮助其减少 80% 的交易容量，目前已为门罗币降低 97% 的交易费用。门罗币采用 BulletProofs 零知识证明机制来帮助用户在公共账本中隐藏交易金额。同时为了确保交易的有效性，需要证明输入金额大于等于输出金额，其中用到了 BulletProofs 中的 range proofs，来降低生成证明所占用的空间。

##### zk-STARKs

*zk-STARKs* 于2018年为解决 DPM（DNA profile matching）问题而提出，是一种基于 IOP 模型的零知识系统。该协议提供了可扩展的、透明的（不需要初始信任设置）抗量子零知识协议，并进一步降低了证明的大小。zk-STARKs 结合 zk-IOP 以及 zk-PCP 两类零知识体系进行了讨论，并给出了实现的[方法](https://github.com/elibensasson/libSTARK)。    

目前项目 [StarkWare](https://www.starkware.co/) 将 zk-STARKs 整合在区块链系统当中；Ethereum Layer2 中也将引入 zk-STARKs。  

除此之外零知识证明与智能合约中结合增强隐私保护（如[Arpachain]( https://arpachain.io/)）和实现基于区块链的公平交换（如[Fairswap](https://eprint.iacr.org/2018/740.pdf )）。

### 2.3 累加器

**累加器的定义**

累加器（Accumulator）是一类单项函数，它以包含多个元素的集合 $S=\{s_1,...,s_n\}$ 作为输入，输出一个常数大小的累加值 $u$；同时，存在一个有效的算法，对集合 $S$ 中的每个元素 $s_i$，输出一个证据 $w_i$，使得任意验证者在给定 $(u,s_i,w_i)$ 的情况下可以有效的验证 $s_i$ 是 $u$ 的输入集合中的元素。累加器的安全性要求，对于一个不属于集合 $S$ 的元素 $s^,$，攻击者无法生成对应的证据 $w^,$，使得 $s^,$ 被验证为 $u$ 的输入集合中的元素。累加器可用于承诺协议、环签名、零知识证明协议等其他密码协议的构造。

**累加器的性质**

一般地，累加器需要满足以下三个功能特性：

1. 支持成员关系证明（membership witness）：对于集合 M 里的每一个成员 m，证明者都可以高效地生成证明该成员 m 属于集合 M 的证据；
2. 支持非成员关系证明（non-membership witness）：对于集合 M 外的任何一个成员 n，证明者都可以高效地生成证明该成员 n 不属于集合 M 的证据；
3. 支持成员动态更新（dynamics）：集合 A 中的每一个成员和其对应的成员关系证明证据可以动态更新。

从安全证明的角度看，累加器可具有单向性、不可区分性、抗碰撞性和不可抵赖性。

**常见的累加器的构造方法**

- 基于 Strong RSA 相关假设：比较典型的构造有 [Benaloh93]( https://www.scopus.com/record/display.uri?eid=2-s2.0-0002809150&origin=inward )，[Baric97](  https://link.springer.com/chapter/10.1007%2F3-540-69053-0_33  )，[Camenisch02](  https://link.springer.com/chapter/10.1007%2F3-540-45708-9_5 )，[Lipmaa12](  https://link.springer.com/chapter/10.1007%2F978-3-642-31284-7_14 )；
- 基于双线性对：比较典型的构造有 [Nguyen05](  https://link.springer.com/chapter/10.1007%2F978-3-540-30574-3_19 )，[Damgård08](   https://www.scopus.com/record/display.uri?eid=2-s2.0-85051020159&origin=inward  )，[Camenisch09](  https://link.springer.com/chapter/10.1007%2F978-3-642-00468-1_27  )，[Acar11](   https://link.springer.com/chapter/10.1007%2F978-3-642-19379-8_26 )；
- 基于哈希函数/Merkle 树：比较典型的构造有 [Nyberg96](  https://link.springer.com/chapter/10.1007%2F3-540-60865-6_45  )，[Buldas00](  https://www.scopus.com/record/display.uri?eid=2-s2.0-0034449541&origin=inward  )，[Boneh14](  https://link.springer.com/chapter/10.1007%2F978-3-662-45611-8_3  )，[Libert16](   http://refhub.elsevier.com/S1084-8045(18)30362-X/sref100  )；

其中基于 Strong RSA 问题的累加器所需要的公开参数长度很小，且每个元素对应的证据长度与集合大小无关。基于双线性对的累加器的公开参数和输入的集合大小线性相关，针对每个元素的证据长度与集合大小无关，在需要累加的集合大小较小时效率较高。这两类累加器和零知识证明协议有很好的兼容性，都有针对它们的零知识证明议。第三类累加器即 Merkle 树，是将待累加集合中的所有元素作为 Merkle 树的叶子节点，将 Merkle 树的根部作为累加值；同时，针对每一个元素（即叶子节点），其证据是对应的杂凑路径。Merkle 树作为累加器的特点是公开参数较小，对每个元素的证据大小为集合大小的对数级，计算效率较高。但由于常用的杂凑函数缺乏代数结构，难以针对其设计特定的零知识证明协议，而需要首先将 Merkle 树的计算和验证过程用电路表示，在应用面向通用电路的零知识证明协议。  

**累加器在区块链中的应用**

基于累加器的成员关系证明在区块链中被用于增强交易的隐私。交易的支付者不再需要在交易单中明确由哪个账户支付该费用，仅需要提供一个包含多个账户的集合且证明所使用的账户是该集合的成员即可。累加器作为一种实现成员关系证明的重要技术，也被广泛使用在区块链系统中。

- 在 [Zerocoin]( http://zerocoin.org/) 中，用一个累加器 A 来证明某个节点对某笔交易拥有使用权。具体而言，累加器 A 的的计算如下
  $$
  A=u^{c_1c_2...c...c_n}\mod N
  $$
  其中整数 A，u，N 是公开的；c 是由硬币序列号（coin serial number ） s 和随机数 z 得到的 Pedersen 承诺（Zerocoin 利用随机数生成器 RNG 产生 s 和 z 使得 c 为质数）；c 的成员关系证明证据 w 定义如下：
  $$
  w=u^{c_1c_2...c_n}\mod N
  $$

- [ZeroCash](http://zerocash-project.org/) 项目组采用 Merkle 树作为累加器，而针对 [Monero](https://www.getmonero.org/) 的新协议 [RingCT 2.0](  https://eprint.iacr.org/2017/921.pdf) 采用的是基于双线性映射的累加器。 

- 在 2019 年的美密会上，Boneh 等人提出将累加器用于区块链上的区间证明 [Boneh19]( https://eprint.iacr.org/2018/1188.pdf  ) , 但目前还没有落地的工程项目。

### 2.4 伪随机函数

**伪随机函数的定义和性质**

伪随机函数（Pseudorandom Function, PRF）是一类带密钥的函数族，可表示为 $PRF=\{F_k:\{0,1\}^{\lambda}\rightarrow\{0,1\}^{O(\lambda)}\}$，其中 $k$ 是一个伪随机函数的密钥。伪随机性是伪随机函数的安全特性，即对于均匀随机选取的 $k$，函数 $F_k$ 和$\{0,1\}^{\lambda}\rightarrow\{0,1\}^{O(\lambda)}$ 的所有函数中随机选取的某个函数不可区分。

**区块链中常用 PRF 的构造方法**

- 基于 DDH 困难问题的伪随机数：该类函数依赖于一个将任意字符串映射到素数$p$阶群中元素的随机函数$h:\{0,1\}^*\rightarrow G$，对于任意的字符串 $x$ 和密钥 $k\in Z_p$ ，该伪随机函数可以定义为 $F_k(x)=h(x)^k$。在实际部署中，随机函数基于杂凑函数实现，因此该方案的安全性是基于随机预言机模型的。
- 基于杂凑函数的伪随机函数：该类伪随机函数的构造更为简洁。对于任意长度字符串输入 $x$ 和固定长度的密钥 $k$，直接计算 $F_k(x):=h(x||k)$，其中 $h$ 为任意杂凑函数。这种构造方法的安全性也是基于随机预言机模型的。

**PRF 在区块链中的应用**

伪随机函数在区块链系统中的重要作用是为匿名货币提供唯一标识。考虑以下典型场景：数字货币 $c$ 是某秘密消息 $x$ 的承诺值，则其唯一标识是 $F_k(c)$。由承诺的绑定性可知承，$k$ 与承诺值 $c$ 唯一对应。由于 $F_k(\cdot)$ 是确定性函数，可知$c$对应了唯一的 $F_k(c)$ 值。另外，由于 $F_k(c)$ 的伪随机性和承诺方案的隐藏性，攻击者无法通过观察 $F_k(c)$ 获知任何关于 $c$ 的信息。

在 [ZeroCash](http://zerocash-project.org/) 和 [Monero](https://www.getmonero.org/) 等匿名数字货币系统中，当支付者匿名的花费了某个数字货币 $c$ 时，同时应该向区块链提供货币对应的唯一标识，即 $F_k(c)$。由于 $F_k(c)$ 与 $c$ 一一对应，故当 $F_k(c)$ 在区块链系统中出现两次时，可以认为有重复花费行为，从而可以拒绝第二次出现该值的交易单入块，从而防止了双重花费攻击。

需要注意的是，为了确保货币$c$支付者提供了正确的 $F_k(c)$，支付者需要在交易单上添加一个零知识证明来说明 $F_k(c)$ 的正确性。基于 DDH 困难问题的伪随机函数拥有基于离散对数难题的特定的零知识证明协议可以证明其正确性；而基于杂凑函数的伪随机函数通常需要依赖面向通用电路的零知识证明协议来完成证明。

## 三、面向区块链业务应用的密码技术

除了实现基本业务功能以外，区块链系统也搭建了一个可公开访问、公开验证的大型去中心化信息平台。利用这一平台，很多传统网络架构下难以解决的难题都找到了基于区块链的解决途径。在这个过程中，密码技术同样扮演了至关重要的角色。

<table> 
  <tr>  <th colspan="2">名称</th><th>主要特点</th><th>数学依赖/构造方法</th><th>应用项目/研究论文</th></tr> 
  <tr><td rowspan="3">区块链上随机数生成</td><td>随机数提取器</td><td>从弱随机源中提取出多个均匀分布的随机比特</td><td>存在弱随机源</td><td><a href="https://arxiv.org/pdf/1605.04559.pdf">Bitcoin Beacon </a>等</td></tr>  
  <tr>                        <td>可验证延迟函数</td><td>定时计算性、运算串连性、结果唯一性</td><td>未知阶群的平方运算、超奇异同源曲线、双线性映射</td><td>以太坊 2.0 信标链、<a href="https://www.chia.net/">chia Network</a>等</td></tr>
  <tr>                        <td>可验证随机函数</td><td>类似于一个带验证条件的伪随机数发生器</td><td>双线性映射</td><td><a href="https://www.algorand.com/">Algorand</a>、<a href="http://arxiv.org/abs/1711.09756">Witnet network</a>、<a href="https://eprint.iacr.org/2017/573.pdf">Ouroboros Praos</a>、<a href="https://dfinity.org/">Dfinity network</a>、<a href="https://eprint.iacr.org/2017/406.pdf ">OmniLedger</a> 等</td></tr>
  <tr><td rowspan="3">秘密分享</td><td>一般形式的秘密分享</td><td>只需部分特定参与者合作通过将他们的碎片凑在一起便可恢复整个秘密</td><td>拉格朗日插值多项式理论</td><td><a href="https://medium.com/clavestone/bitcoin-multisig-vs-shamirs-secret-sharing-scheme-ea83a888f033">比特币钱包</a>、<a href="http: //arxiv.org/abs/1803.04861">SHARVOT</a>、<a href="https://pdfs.semanticscholar.org/ab9f/b027061fb4aa8ed8017d63002f586a18eab6.pdf">mini blockchain</a> 等</td></tr>  
  <tr>                        <td>可验证秘密分享</td><td>允许秘密分享者对重构秘密进行验证</td><td>基于 Shamir 门限体制</td><td><a href="https://eprint.iacr.org/2018/209.pdf">Calypso</a>、<a href="https://eprint.iacr.org/2018/460.pdf">RapidChain</a> 等</td></tr> 
  <tr>                        <td>可公开验证秘密分享</td><td>允许任何人（不仅仅是分享者）可检验秘密碎片分发过程的正确性</td><td>RSA 假设、承诺协议等</td><td><a href="https://eprint.iacr.org/2016/889.pdf">Ouroboros</a>、
      <a href="https://eprint.iacr.org/2017/216.pdf">SCRAPE</a>、
      <a href="https://eprint.iacr.org/2016/1067.pdf">RandHerd</a> 等</td></tr> 
  <tr><td colspan="2">分布式秘钥生成</td><td>在面向群体的密码学中起着非常重要的作用</td><td>可验证秘密分享协议</td><td>
      <a href="http://www.annchain.io/">Annchain</a>、
      <a href="https://www.wanchain.org/zh/homepage/">WanChain</a>、
      <a href="https://www.fusion.org/">Fusion</a>、
      <a href="https://eprint.iacr.org/2018/209.pdf">Calypso</a>、
      <a href="https://eprint.iacr.org/2016/199.pdf">Honey Badger</a> 等</td></tr> 
  <tr><td colspan="2">安全多方计算</td><td>无可信第三方的多方协作计算</td><td>混淆电路、全同态加密</td><td><a href="https://arxiv.org/abs/1807.09484">Raziel</a>、
      <a href="https://arxiv.org/abs/1506.03471">Enigma</a>、
      <a href="https://eprint.iacr.org/2015/675.pdf">Hawk</a> 等</td></tr> 
  <tr><td rowspan="2">基于区块链的文件系统中的密码学技术</td><td>远程文件存储检测技术</td><td>允许用户花费少量的通信量进行存储于外包服务器上数据完整性的远程校验</td><td>副本证明、时空证明</td><td>
      <a href=" https://filecoin.io/ ">Filecoin</a>、
      <a href="https://ieeexplore.ieee.org/document/6956582">Permacoin</a> 等</td></tr>  
  <tr>                        <td>文件分享与谓词加密</td><td>持依据谓词关系实施访问控制策略</td><td>身份基加密、属性基加密、广播加密等</td><td>
      <a href=" https://steem.com/steem-whitepaper.pdf">Steem</a>、
      <a href=" https://safenetwork.org/ ">SAFE Network</a>、
      <a href=" https://doi.org/10.1007/s10916-016-0574-6">Healthcare</a>、
      <a href=" https://onlinelibrary.wiley.com/doi/full/10.1002/sec.1748">Fairaccess</a> 等</td></tr>
  <tr><td rowspan="1">基于区块链的身份认证系统中的密码学技术</td><td>Identity Mixer 身份认证技术</td><td>假名机制、证书灵活</td><td>Camenisch-Lysyanskaya 签名方案</td><td><a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/idemix.html">Hyperledger</a></td></tr>  
</table>    

### 3.1 区块链上随机数生成  

随机数在网络空间和现实世界都扮演着十分重要的地位。以彩票系统为例，一个公平的彩票系统应该确保每一期的中奖号码都是随机数，且其生成方式具备公开可验证性，不可预测性和抗偏置性等性质。

- 公开可验证性：产生的随机数必须可以被公开地验证其确实是通过该方式产生的。这一性质保证了负责生成随机数的实体无法简单地通过更改生成方式来改变输出结果。

- 不可预测性：被动的攻击者无法通过观察系统来提前预测结果。
- 抗偏置性：积极的攻击者无法通过操纵系统或隐瞒结果来使输出的随机数的统计分布不是均匀分布。

在现实世界的彩票系统中，为了保证公开可验证性，彩票运营方通常通过电视直播的方式来展示中奖结果选定的过程。为了保证不可预测性和抗偏置性，运营方通常选择专门制造的选取中奖号码球的机器，且通过设置物理限制防止他人接触该机器，避免对系统产生偏置。但在网络空间中，由于缺乏类似于掷硬币选小球这样的随机性事件，使得以可验证的方式产生随机数变得困难。区块链系统由于高度去中心化的性质，其区块的杂凑值、PoW 中寻找的随机数都可以视为随机性的来源。但要利用这些随机性来源，产生不可预测抗偏置的随机数，仍然需要密码技术的保证。

#### 3.1.1 随机数提取器

随机数提取器（Randomness Extractor）是一种函数，可以从带有相关位的随机源（称为弱随机源）中，提取出多个均匀分布的随机比特。这一概念最早被提出并应用于模拟随机化算法，但随着进一步的研究，随机数提取器在密码学和分布式计算等领域找到了更多的应用。

**随机数提取器在区块链中的应用**

随机数提取器工作的前提条件是存在一个弱随机源。比特币等使用 PoW 机制的区块链系统中，每一区块生成时中挖矿产生的随机数本身就具备较高的随机性，且由于挖矿机制中存在算力竞争，大部分节点在找到符合要求的随机数后不会再去根据其他选择对产生的随机数进行二次筛选，这也降低了该随机源的偏置性。

- [Bitcoin Beacon](https://arxiv.org/pdf/1605.04559.pdf) 是首个结合区块链和随机数提取器实现可验证抗偏置随机数生成的系统。该项目针对比特币系统专门设计，证明了在攻击者不能过于频繁地抛弃其生成的区块的假设下，可以从比特币区块链系统中提取出无偏置且可以公开验证的随机数。关于将比特币系统作为随机源的研究还有论文 [On Bitcoin as a public randomness source]( https://eprint.iacr.org/2015/1015.pdf )。
- [Scafuro](https://eprint.iacr.org/2019/066) 等人也证明了只需要假设在足够长的区块链序列中存在常数个区块由不同的诚实节点生成，那么区块链上也一定具有足够提取固定随机比特的随机源。

#### 3.1.2 可验证延迟函数 

**VDF 的定义和性质**

VDF（Verifiable Delay Functions）是这样一类函数$f: \mathscr{X}\rightarrow  \mathscr {Y}$, $f$ 的运算需要通过指定时间得到输出结果，即使在 CPU 并行运算下也不能加速；对于每一个输入 $x\in  \mathscr {X}$， $f$都有唯一的输出 $y\in  \mathscr {Y}$，且该输出结果可以被公开的、快速地验证。Dan Boneh 等人 2018 年在 CRYPTO 的论文 [Verifiable Delay Function](https://eprint.iacr.org/2018/601) 中给出了 VDF 的形式化定义。  

具体而言，一个 VDF 的构造需要通过三个算法：

1. $Setup(\lambda,T) \rightarrow pp $： 给定安全参数 $\lambda$ 和指定时间 $T$，输出公共参数 $pp$；
2. $Eval(pp,x) → (y,π)$：给定输入和 $x\in  \mathscr {X}$ 公共参数 $pp$，输出 $y\in  \mathscr {Y}$ 和证明 $\pi$；
3. $Verify(pp,x,y,π) → {accept,reject} $：当且仅当 $y$ 是 $x$ 的正确的 VDF 输出结果时，$Verify$ 输出 $accept$。

根据以上定义， VDF 还有一些拥有特殊性质的变种： 可解码 VDF（Decodable VDF）、 增量 VDF（Incremental VDF）、 陷门 VDF（Trapdoor VDF）和 弱 VDF（Weak VDF）。

一般的，VDF 具有以下性质：

-  定时计算性（$\epsilon$-evaluation time）：对于任意的输入 $x\in  \mathscr {X}$ 和任意的由 $Setup(\lambda,T)$ 生成的公开参数 $pp$，算法$Eval(pp,x)$ 的运行时间至多为 $(1 + \epsilon)T$；
- 运算串行性（Sequentiality）：对于某个至多使用 $poly(λ)$ 个处理器的并行算法 $A$，$A$ 不能再时间 $T$ 内完成 VDF 的运算。特别地，对于任意的输入 $x\in  \mathscr {X}$ 和任意的由 $Setup(\lambda,T)$ 生成的公开参数 $pp$ ，如果 $(y,π)\leftarrow Eval(pp,x)$，则概率 $Pr[A(pp,x)=y]$ 是可忽略的；
- 结果唯一性（Uniqueness）： 对于一个输入 $x\in  \mathscr {X}$，有且仅有一个 $y\in  \mathscr {Y}$ 满足 $Verify$ 输出的结果是 $accept$。特别地，假设存在一个高效的算法 $A$ 满足：给定公开参数 $pp$ 为输入，$A$ 输出 $(x,y,π)$ 满足 $Verify(pp,x,y,π) = accept$，则概率 $Pr[Eval(pp,x)\not= y]$ 是可忽略的。

**VDF 的构造方法**

- 在论文 [Verifiable Delay Function](https://eprint.iacr.org/2018/601) 中，Boneh 给出了 VDF 的应用场景以及形式化的模型，安全分析和一般构造方法。
- 之后出现了两篇 VDF 的构造论文，分别是 Wesolowski 的 [Efficient VDF](https://eprint.iacr.org/2018/623) 以及 Pietrzak 的 [Simple VDF](https://eprint.iacr.org/2018/627)。两者都利用在未知阶的群中连续做平方运算的方法来构造 VDF，不同的是，他们生成证明的构造有所区别。简单来讲，Wesolowski 的证明更短，验证更快；但是 Pietrzak 的构造中，生成证明的速度更快，同时证明系统依赖的安全假设更弱。
- 2019 年 [Feo 等人](https://eprint.iacr.org/2019/166) 使用超奇异同源曲线 (Supersingular Isogenies) 以及双线性对构造 VDF。相比于 Wesolowski 和 Pietrzak 的工作，他们的构造本身就是非交互的，不需要经过转换，同时不需要证明 $\pi$ 即可完成验证，但是他们的构造中 Setup 耗费的时间更长，更为主要的是，目前还只能进行 trusted setup。 

更多的 VDF 的构造方法和研究总结可以参考 Boneh 的 [综述](https://eprint.iacr.org/2018/712) 和 https://vdfresearch.org/ 。

**VDF 在区块链中的应用**

以太坊研究团队打算在以太坊 2.0 中引入 VDF，以期望在以太坊 2.0 信标链中使用 RANDAO + VDF 随机选取出块节点；[Chia Network](https://www.chia.net/) 也计划使用 VDF 来支持他们的 Proof-of-Space 共识。

此外，在论文 [Verifiable Delay Function](https://eprint.iacr.org/2018/601) 中， Boneh 提及了 VDF 的一些应用：

- 生成随机信标 (Randomness beacons)

  VDF 可以用于增强区块链上公共可验证随机数的安全性。在基于 POW 共识的区块链中，如果攻击者有时间在其他诚实节点之前预测出随机数的结果，则攻击者可以通过不广播自己挖出的区块来降低自己不想要的随机数结果出现的概率。使用 VDF 阻止这种攻击：将 VDF 的时间参数设置的足够长（比如 6 个区块以上的间隔），并将当前最新的区块头数据作为 VDF 的输入，将输入结果作为随机数的结果。那么在至少 6 个区块以后攻击者才能知道随机数的值，这时很难再对区块链做出改变。

- 构建资源高效的区块链 (Resource-efficient blockchains)

  VDF 可用于构造非 POW 共识，如 Cohen 的论文 [Proofs of space and time]( https://cyber.stanford.edu/sites/default/files/bramcohen.pdf.) 中采用增量 VDF 来不需要大量运算的区块链共识；VDF 可用于选取出块节点。

- 生成副本证明 (Proof of replication)

  可解码 VDF 可以作为一种非对称时间编码和解码技术用于构造副本证明，可提高区块链上存在性证明方案的效率，如 [Proof of unique blockchain storage](  https://bitslog.wordpress.com/2014/11/03/proof-of-local-blockchain-storage/) 。

- 计算时间戳 (Computational timestamping)

  VDF 相当于一种时间流逝的证明，对于给定的 VDF，该 VDF 至少需要多久才能得出结果是一个公共知识。因此，只需要在 基于 POS 共识的区块链上包含 VDF 的输入与输出即可证明给定区块的历史，这种类似于计算时间戳的功能可用于抵抗 POS 的长程攻击（Long-range Attack）。 

#### 3.1.3 可验证随机函数

**VRF 的定义**

[可验证随机函数（Verifiable Random Function，VRF）](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Silvio_Micali)是由 [Micali](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Silvio_Micali)、 [Rabin](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Michael_O._Rabin)、[Vadhan](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Salil_Vadhan) 三位密码学家在 1999 年提出的。VRF 是一种 pseudo-random function（属于 Pseudorandom function family），它提供了一种公有的验证方法去验证输出的正确性，其一般定义如下：

设 G， F,，V 都是多项式时间算法；其中 G （函数参数生成单元）是概率算法，以 $1^k$ 为输入，输出 PK，SK； $F= F_1, F_2$ （函数计算单元） 是确定性算法，输入为 SK，x ；输出 $value= F_1(SK,x)$ ，$proof = F_2(SK,x) $；V（函数验证单元） 是概率算法，输入为 $(PK, x, value, proof)$，输出为 YES 或 NO 。设 $a: N \rightarrow N \cup\{*\}$，$b,s: N \rightarrow N$ 是 3 个函数，使得 $a(k),b(k),s(k)$在 时间 $poly(k)$ 内可计算。若下列性质满足，我们称 (G, F, V) 是可验证随机函数 (VRF) :

1. $(PK,SK) \stackrel{R} {\leftarrow }G(1^k)$, 下列条件以 $1-2^{-\Omega(k)}$ 的概率成立：(1) 对于所有的 $x\in \{0,1\}^{a(k)}$,$F_1(SK,x)\in \{0,1\}^{b(k)}$; (2) 对于所有的 $x\in \{0,1\}^{a(k)}$, 若 $(value,proof)=F(SK,x)$, 则 $Pr[V(PK, x, value, proof)]=YES >1-2^{-\Omega(k)} $;

2. 对所有的 $PK, x, value_1, value_2, proof_1,proof_2$, 并且 $value_1 \not= value_2$, 则对任意的 $i=1,2$, $Pr[V(PK, x, value_i, proof_i)]=YES < 2^{-\Omega(k)} $;

3. 设 $T=(T_E,T_J)$ 是一对算法，输入为 $1^k$ 时，$T_E(\cdot,\cdot)$, $T_J(\cdot,\cdot)$ 的运算不超过 $s(k)$ 步。则 $T=(T_E,T_J)$ 在下列实验中成功的概率至多为 $\frac{1}{2}+\frac{1}{s(k)}$;

   - $(PK,SK) \stackrel{R} {\leftarrow }G(1^k)$;

   - 运行 $T_E^{F(SK,\cdot)}(1^k,PK)$，得到 $(x,state)$;

   - $r \stackrel{R} {\leftarrow }\{0,1\}$, 如果 $r=0$，则令 $value=F_1(SK,x)$; 如果 $r=1$，则 $value\stackrel{R} {\leftarrow }\{0,1\}^{b(k)}$;

   - 运行 $T_J^{F(SK,\cdot)}(1^k,value,state)$ 得到 $guess$;

   - 如果 $x\in \{0,1\}^{a(k)}$, $guess=r$ 且 $x$ 没有被 $T_E$ 或者 $T_J$ 询问过，则称 $T=(T_E,T_J)$ 成功。
     可以简单的将 VRF 看成一个**带验证条件的随机预言机** ： value 是一个随机数，它的值均匀分布在值域范围内； 对于相同的 x 一定会有相同的 value ； 可验证随机函数比随机预言机多了一个非交互的零知识证明 proof，可以用来该随机数输出的正确性，表明这个随机数的确是某个人生成的。

     更详细的 VRF 介绍可参考 https://tools.ietf.org/html/draft-goldbe-vrf-01.html 

**基于双线性映射的 VRF 构造**

1. $G(1^k)$: 从 $Z^{*}_p$ 中任选 $s$, 并令 $SK=s,PK=g^s$;
2. $F=(F_1,F_2): value=e(g,g)^{1/(x+s)}, proof=g^{1/(x+s)}$;
3. $V$: 若 $e(g^x\cdot PK, proof)=e(g,g)$ 且 $value=e(g,proof)$, $V$ 输出 1, 否则输出 0。

通过这种方法构造的 VRF 的安全性依赖于 [decisional bilinear Diffie-Hellman inversion assumption](https://en.wikipedia.org/w/index.php?title=Decisional_bilinear_Diffie-Hellman_inversion_assumption&action=edit&redlink=1 ) 假设，即给定 $(g,g^x,...,g^{(x^q)},R)$ 为输入，区分 $R=e(g,g)^{1/x}$ 和对应区间内的随机数。

**VRF 在区块链中的应用**

- **VRF 一般用在基于 POS 共识的区块链中**

  VRF 可作为密码学工具用来进行 POS 共识中每轮的领导者或委员会选举。例如，[Algorand](https://www.algorand.com/) 和 [Witnet network](http://arxiv.org/abs/1711.09756) 中用 VRF 进行进行抽签选取出块节点； [Ouroboros Praos]( https://eprint.iacr.org/2017/573.pdf) 中基于当前时刻的时间戳和 nonce，用 VRF 决定参与者是否有资格发布区块； [Dfinity network]( https://dfinity.org/ ) 使用 VRF 生成随时间变化的输出流；[OmniLedger]( https://eprint.iacr.org/2017/406.pdf ) 也用 VRF 进行每轮领导者的选举。

  在区块链项目中，基于 VRF 的抽签运行算法有如下特点：抽签过程不需要与其他通信，直接在本机就能够的到这个抽签结果，而且抽签过程的输入 $x$ 是参与者公认的，针对同一个 $x$ 的输出 $value$ 是固定的，因此无法通过多次尝试来改变抽签结果 ；某个节点收到其他节点的抽签信息之后，可以用附带的证明，来证明这个随机数的正确性，保证它的确是由对应私钥的拥有者计算出来的，因此这个抽签结果是无法被伪造的。在 Algorand 中，VRF 主要用来得出一个伪随机数，抽签的部分主要是由一个二项分布函数负责，而通过构建二项分布的参数，可以很方便的控制需要被得出的中签权益的个数，适配不同的需要抽签的场景 。


### 3.2 秘密分享

#### 3.2.1 一般形式的秘密分享

**秘密分享的定义和性质**

秘密分享的概念由 Shamir 在 1979 年提出，其基本思想是将秘密分成多个碎片 (piece) 并将这些碎片分发给不同的人掌管；这些人中的某些特定子集可以通过将他们的碎片凑在一起恢复整个秘密。秘密分享构成了门限密码学的基础。秘密分享可用在诸如签署文件或支票以及打开银行保险柜箱等活动中以分散信任和共享控制。

一般地，一个有秘密分发者 $D$ 和 $n$ 个参与者 $P_1,P_2,...,P_n$ 构成的 $(k,n)$ 秘密分享体制包含下面两个协议：

1. 秘密分发协议：秘密分发者 $D$ 在 $n$ 个参与者中分享秘密 $s$，每个参与者 $P_i$ 获得一个碎片 $s_i, i=1,...,n$；
2. 秘密重构协议：任意不少于 $k$ 个参与者一起合作，以各自的碎片为输入，可重构原秘密 $s$。

可将这种关系记为：$(s_1,...,s_n) \stackrel{(k,n)} {\longleftrightarrow }s$。

一个安全的 $(k,n)$ 秘密分享体制需要满足以下两条性质：

- 任意 $k$ 个参与者通过提供自己的碎片并能够协作恢复出原秘密 $s$；
- 任意少于 $k$ 参与者无法合作计算得到关于原秘密的 $s$ 的任何信息。

**经典 Shamir 秘密分享构造方案**

Shamir 在提出秘密分享思想的同时，也利用拉格朗日插值多项式理论构造了一种经典的秘密分享构造方案（SSSS），该方案广泛应用于门限密码学、安全多方计算等领域。

1. 系统参数：$n$ 为全部参与者的人数，$k$ 为门限值，$F_q$ 是 $q$ 阶有限群，其中 $q>n$ 。令 $q=p$ 为质数，令$F_q=Z_p$，设欲分享的秘密为 $s\in Z_p$；
2. 秘密分发：秘密分发者 $D$ 选择一个 $k$ 阶的随机多项式 $a(x)\in_RZ_p[x]$，满足条件 $a(0)=s$。$D$ 将$s_i=a(i)$ 发送给参与者 $P_i$，$i=1,2,...,n$；
3. 秘密重构： 不失一般性，可设欲重构该秘密的 $k$ 个参与者为 $P_i$，$i=1,2,...,k$。令 $M=\{1,2,...,k\}$，计算 $\lambda_i=\prod_{j\in A,j\not=i}\frac{j}{j-i}$，然后通过计算 $s=\sum_{i\in A}{s_i\lambda_i}$ 可恢复原秘密 $s$。

可以验证，$a(x)$ 是经过点 $(i,s_i)$，$i\in A$ 且次数小于 $k$ 的唯一多项式，其拉格朗日插值公式为$a(x)=\sum_{i\in A}{s_i\prod_{j\in A,j\not=i}\frac{x-j}{j-i}}$.

**秘密分享在区块链中的应用**

- 秘密分享可用于 [比特币钱包的私钥管理](https://medium.com/clavestone/bitcoin-multisig-vs-shamirs-secret-sharing-scheme-ea83a888f033)，通过将钱包私钥分发管理以增强其安全性；
- 也有研究者 [将 Shamir 秘密分享机制用于区块链中的交易数据分发]( http://ita.ucsd.edu/workshop/18/files/paper/paper_1714.pdf )，在不过多损失数据完整性的条件下通过提高数据的存储效率；
- 秘密分享也被用于设计区块链上安全投票协议，例如 [SHARVOT]( http: //arxiv.org/abs/1803.04861)；或用于设计 [mini blockchain]( https://pdfs.semanticscholar.org/ab9f/b027061fb4aa8ed8017d63002f586a18eab6.pdf) 。

#### 3.2.2 可验证秘密分享

在 Shamir 的秘密分享构造方案中，所有的参与者是被默认为诚实的，但这种假设不是在所有分布式网络环境中都成立的，更多时候需要考虑存在恶意节点的情况。针对这一问题，Chor 等人在 1985 年首次提出了可验证秘密分享（Verifiable Secret Sharing ），在原有的密码分享的基础上增加了一个验证算法，允许秘密分享者对重构秘密进行验证。

**经典的 VSS 构造方案**

- Feldman 于 1987 年提出了不需可信机构的非交互式 $(k,n)$ 门限 VSS 协议 Feldman VSS， 该协议是基于 Shamir 的门限体制和计算离散对数的困难性假设的。由于其效率较高， 在门限密码学 、分布式密钥生成、 安全多方计算等诸多方面得到了广泛的应用。该协议能够抵抗包括分发者在内的 $( n- 1) /2$ 个恶意参与者的合谋攻击。

- Pedersen 给出了一个具有同态性质的安全的承诺方案，之后基于拉格郎日多项式插值法， 提出了第一个信息论安全（无条件安全） 的非交互式可验证秘密分享方案（简称为 Pedersen VSS）。 这一方案的信息速率为 $1/ 2$， 与 Feldman VSS 方案一样具有较高的效率。

**VSS 在区块链中应用**

- VSS 可用于实现基于区块链的数据安全分享和管理平台，例如在 [Calypso](https://eprint.iacr.org/2018/209.pdf ) 中，VSS 用于保证恶意节点存在的情况下，区块链上数据共享过程的实时性和公平性；
- 在 [RapidChain]( https://eprint.iacr.org/2018/460.pdf ) 中，经典 Feldman VSS 协议被用于生成无偏差的随机数，来用于委员会对其 epochs 进行随机化。

#### 3.2.3 可公开验证秘密分享

在大多数经典 VSS 构造方案中，只有分享者本人才能验证他自己收到的秘密碎片的正确性。这使得 VSS 的应用在一定程度上受到了限制。1996 年，Stadler 提出了可公开验证的密码分享方案（PVSS），该方案允许任何人（不仅仅是分享者）都可以检验秘密碎片分发过程中的正确性。

**经典 PVSS 构造方案**

- Stadler 给出了 PVSS 的一个非形式化的模型，同时还给出了两个 PVSS 协议，其中的一个基于对离散对数的可验证加密，另一个基于对模复合数的 $e$ 次根的可验证加密。由于通信和计算代价都很大，这两个协议的效率都很低。
- Fujisaki 和 Okamoto 于 1998 年利用了几个高效的承诺方案和基于改进的 RSA 假设，提出了一个效率相对较高的 PVSS 方案。
- 基于以上两个方案，Schoenmakers 提出了一种改进的模型，要求每一分享者在恢复算法中不仅提供其秘密碎片， 而且要提供其秘密碎片正确性的证明。这种模型下构造出的 PVSS 方案更加简捷、安全性和高效。其安全性所依赖的困难问题是离散对数问题和 Diffie-Hellman 判定问题。

**PVSS 在区块链中的应用**

- PVSS 用于区块链上随机信标（Randomness Beacon）的生成：在许多采用非 POW 共识（POS 共识或者混合共识）的区块链设计中，例如 [Ouroboros]( https://eprint.iacr.org/2016/889.pdf  ) 、[SCRAPE]( https://eprint.iacr.org/2017/216.pdf ) 、 [RandHerd](https://eprint.iacr.org/2016/1067.pdf) 等，PVSS 用于生成随机信标以选举出块节点或委员会；

### 3.3 分布式密钥生成

分布式的密钥生成 (Distributed Key Generation， 简称 DKG)，是门限密码系统及分布式密码计算的重要组成部分，在面向群体的密码学中起着非常重要的作用。它允许多个参与者共同合作以生成一个密码系统的公钥和私钥， 使得公钥以公开形式输出， 而私钥被参与者按照某一秘密分享方案所分享。 这一被分享的私钥以后可以用于面向群体的密码系统，如群体签字或群体解密。大多数 DKG 方案中分布式密钥的产生不依赖任何可信的第三方 。

第一个 DKG 方案是由 Pedersen 于 1991 年提出的。该方案后来被多次修改并被多次用于门限密码学及其应用的研究中。Pedersen 的 DKG 协议的基本思想是并行执行 $n$ 次 Feldman 的可验证秘密分享协议，其中，每一参与者 $P_i$ 作为分发者把他随机选择的秘密值 $z_i$ 可验证的在所有参与者中分享，最终的秘密钥 $x$ 为 $x=\sum_{i=1}^{n}{z_i}$ 之和， 最终的公钥 $y$ 为 $y=\prod_{i=1}^{n}{g^{z_i}}$。更多的 DKG 构造方法可参考 [GJKR07]( https://link.springer.com/article/10.1007/s00145-006-0347-3 )、  [DKG wiki](https://en.wikipedia.org/wiki/Distributed_key_generation)。

**DKG 在区块链中的应用**

- 区块链作为分布式系统，其运行也不依靠可信第三方，因此区块链中的节点通过 DKG 分布式地产生密钥，克服单点故障以及单个节点不可信任问题。如在 [Annchain]( http://www.annchain.io/ ) 项目中， DKG 被用于和可验证随机数 (VRF) 一起保障在公开网络环境下公平选举出 Sequencer 的潜在节点，不定期进行轮换。
- DKG 也被用于区块链的跨链方案设计中，如 [WanChain](https://www.wanchain.org/zh/homepage/  )、[Fusion]( https://www.fusion.org/ ) 等。
- DKG 是门限密码系统的重要组成部分，因此在区块链中使用其他门限密码方案时往往也会用上 DKG，如 [Calypso](https://eprint.iacr.org/2018/209.pdf )、[Dfinity]( https://dfinity.org/ )、 [Honey Badger](https://eprint.iacr.org/2016/199.pdf )。
- 也有研究者 [基于以太坊智能合约构造新的 DKG 生成方案]( https://www.sqi.at/resources/Schindler-2019-CIW-Distributed-Key-Generation-with-Ethereum-Smart-Contracts.pdf )，如 [DKG on EVM]( https://github.com/orbs-network/dkg-on-evm )。

###  3.4 安全多方计算

安全多方计算（Secure Multi-Party Computation，SMPC）的研究主要是针对无可信第三方的情况下，如何安全地计算一个约定函数的问题。安全多方计算是电子选举、门限签名、电子拍卖等诸多应用得以实施的密码学基础 。安全多方计算起源于 1982 年图灵奖得主姚期智的 [百万富翁问题](https://zh.wikipedia.org/w/index.php?title=百万富翁问题&action=edit&redlink=1)，后来 Oded Goldreich 等人有比较细致系统的论述。常见的构造方法有基于加密电路和秘密分享的两种方案， Google 开源了一个 [用于计算隐私交集的安全多方计算方案](https://github.com/google/private-join-and-compute)。

安全多方计算的安全目标通常包括：

1. 输入隐私性，即攻击者可以无法从协议执行过程中获知除了函数输出以外的信息；
2. 正确性，即攻击者无法迫使诚实的参与者输出不正确结果。   

安全多方计算的实现方式主要包括基于混淆电路的实现和基于全同态加密的实现。混淆电路是伴随着安全多方计算这一概念一起出现的密码技术，经过多年发展，目前在计算规模较小时已经有较高的执行效率。而 [全同态加密](  https://www.cs.cmu.edu/~odonnell/hits09/gentry-homomorphic-encryption.pdf ) 是 2009 年由 Gentry 提出，该技术目前离实用化尚有一定距离。目前在区块链中部署的安全多方计算为基于混淆电路的实现。

**安全多方计算在区块链中的应用**

- 安全多方计算技术的使用对提升智能合约的安全性有重大意义。一种典型的应用场景描述如下：首先将智能合约的代码转换为安全多方计算可以处理的函数；各参与方通过交易单的方式将合约所需要的输入按安全多方计算协议提供的方法隐藏后广播；区块链系统的记账节点收到所有的输入后按照安全多方计算协议提供的方法输出结果，并记录到区块链中。以上应用可以保护各方输入和合约本身，支持互不信任的各方完成合约。[Raziel](https://arxiv.org/abs/1807.09484) 项目组提出了将安全多方计算技术应用于智能合约，实现私有可验证的智能合约系统。在 2019 年的安全顶会 ACM CCS 上，来自美国 Indiana University 的研究者提出了一种高效的、可公开验证的安全两方计算协议 [Efficient Publicly Verifiable 2PC](http://homes.sice.indiana.edu/yh33/mypub/pvc.pdf)，并基于区块链智能合约进行实现。
- 安全多方计算在区块链中也可以用于增强隐私保护，如：[Enigma]( https://arxiv.org/abs/1506.03471) 将区块链的信息网络传输网络与 SMPC 网络混合，每个节点只拥有随机的、部分的信息，节点通过安全多方计算可以恢复完整的数据信息。在 [Hawk](https://eprint.iacr.org/2015/675.pdf ) 中，SMPC 用于降低节点间在使用零知识证明时对公共字符串的依赖。

### 3.5 基于区块链的文件系统中的密码学技术

区块链系统所具有的不可篡改、多备份存储、公开可访问的属性使得基于区块链构建的文件存储系统相比传统的文件存储系统有独特的优势。然而区块链系统的开放性允许任何个体成为提供存储服务的节点，这使得传统存储服务模式下对服务商的审计策略无法奏效，服务的可靠性也不能依靠现实世界的信用背书。现有基于区块链文件系统如 [Filecoin]( https://filecoin.io/ ) 使用多种密码技术来保证存储节点提供可靠安全的文件存储服务。可靠安全的文件存储服务包含以下两个要点：（1）真实地按照客户需求存储了文件；（2）严格执行了访问控制策略。本节分别介绍实现这两个要素的密码技术。

#### 3.5.1 远程文件存储检测技术

存储检测伴随着远程文件存储业务开展发展的一类技术。这一类技术的目的在于允许用户可以远程校验存储于外包服务器上数据的完整性，且通信数据量远低于下载全部数据。云计算服务场景下使用的存储检测技术包括数据持有证明（Proof of Data Possession）和可恢复证明（Proof of Retrievability）。所谓可检索证明是指，用户可以通过这一证明确认自己可以从服务商处恢复自己所有的数据；而数据持有证明的功能稍弱，用户可通过和服务商的交互确认服务商确实存储了其所有的数据（但不保证可以获取所有数据）。

数据持有证明和可恢复证明都是面向云服务场景下的技术，而将其推广到区块链系统中时，则面临女巫攻击、外包攻击等攻击形式。女巫攻击是指恶意服务商通过创建多个虚假身份的形式，伪装实现了多备份存储而实际上仅存储了一份文件；外包攻击是指恶意服务商通过借用他人存储的数据，伪装存储了比实际存储更多的文件。

以上攻击能够生效的原因在于，在数据持有证明和可恢复证明中，数据在不同物理设备中存储方式是相同的且仅考虑了当前的存储状态， 因此恶意服务商可以借助一个设备上存储的数据，完成多个设备的存储证明。针对这种情况，[Filecoin]( https://filecoin.io/ ) 项目提出了两种新的远程文件验证技术，即副本证明和时空证明。

- **副本证明**： 该技术是一种新型存储证明技术。通过该技术，诚实的服务商可以向用户证明他为某个文件生成了独特的副本，并将该副本存储在了自己的物理设备上。由于每个设备上存储的副本是不同的，因此恶意的服务商无法用一个设备上存储的文件帮助其余设备完成存储证明。

  副本证明技术可以通过分组加密、zk-SNARKs 和数据持有证明等技术实现。具体的实现可以分为三个阶段：使用分组加密算法对文件 D 进行加密，得到加密副本 R，其中加密密钥与物理设备唯一绑定；利用 zk-SNARKs 技术证明 R 是 D 在特定密钥下的加密结果；利用数据持有证明技术证明其持有 R。

  由于加密密钥与物理设备相关，文件 D 在不同设备上的副本 R 是不同的，因此证明者无法从其他设备处获得副本 R 的持有证明。实现了副本证明所希望的功能。

- **时空证明**： 传统的数据持有证明只能证明存储服务商在生成证明的时间点存储了数据，但如何证明其在一段时间内都存储了该数据是传统的数据证明技术没有考虑到的问题。一种直观的思路是要求存储服务商以较高的频率不停的生成数据证明，但这种方法加重网络负担，不适合实际部署。针对以上问题，[Filecoin]( https://filecoin.io/ ) 提出了一种被称为时空证明的技术。该技术允许存储商以生成较短的证明来表明其在一个时间段内的都存储了某个数据块。从技术角度来说，证明者首先接收验证者发送来的挑战值，生成第一个数据持有证明，然后将该证明和原本的挑战值作为杂凑函数的输入，输出结果作为新的挑战值，再执行下一轮的数据持有证明。由于每一轮的数据持有证明依赖上一轮的证明，所以该过程无法并行执行，从而保证了存储服务商在整个时间段内都存储了该数据。

此外，可恢复证明（Proof of Retrievability）还用在 [Permacoin]( https://ieeexplore.ieee.org/document/6956582 )、[Retricoin](http://doi.acm.org/10.1145/2833312.2833317)、 [Storj]( https://storj.io/storj2014.pdf ) 等区块链项目中。

#### 3.5.2 文件分享与谓词加密

区块链上数据可以被所有节点访问并存储，使得传统的访问控制策略难以部署。因此，区块链上文件分享需要使用密码技术来实行可靠的访问控制策略。

[谓词加密](https://eprint.iacr.org/2007/404.pdf)是一类加密方案，它支持一切可表述为谓词关系的访问控制策略。谓词关系可表示为函数$P:K\times E \rightarrow \{0,1\}$：对于 $k\in K, e\in E$，若 $P(k,e)=1$ 则称 $k,e$ 满足谓词关系 $P$。在谓词加密方案中，每一个私钥都对应了密钥属性空间 $K$ 中的某个属性 $k$；加密阶段加密者需要根据访问控制需要，选择相应的密文属性 $e$。只有私钥具备的属性和密文具备的属性满足谓词关系时，才能利用该私钥从密文中恢复出正确的明文。

谓词加密根据谓词关系定义的不同，可以进一步细分为 [身份基加密](https://crypto.stanford.edu/~dabo/papers/bfibe.pdf)、[广播加密](https://link.springer.com/chapter/10.1007/3-540-48329-2_40) 和 [属性基加密](https://www.caida.org/workshops/ndn/1502/slides/ndn1502_hzhang_p2.pdf) 等多个不同的原型。谓词加密在区块链中的应用并没有特别的要求，和区块链的底层协议基本是解耦的，因此可以灵活选取需要的谓词加密方案部署。基于谓词加密实现访问控制的区块链项目有 [Steem]( https://steem.com/steem-whitepaper.pdf )、[SAFE Network](https://safenetwork.org/)、[Healthcare](https://doi.org/10.1007/s10916-016-0574-6)、[Fairaccess]( https://onlinelibrary.wiley.com/doi/full/10.1002/sec.1748 ) 等。

### 3.6 基于区块链的身份认证系统中的密码技术  

传统的身份认证系统中缺少对 CA 行为的审计，CA 如果存在滥发超发证书的行为，则有可能侵犯合法用户的利益。利用区块链公开可访问、数据记录不可伪造不可篡改等优点，将 CA 签发证书的行为记录在区块链，可以实现对 CA 行为的审计。然而，直接将现有的 PKI 体系迁移到区块链环境下会产生多种安全问题，攻击者可以从链上公开的数据中得到某个用户的认证行为，从而获知其隐私信息。因此，建立基于区块链的身份认证系统需要额外的密码技术来保证其安全性。

#### 3.6.1 Identity Mixer 身份认证技术

[Identity Mixer]( https://www.zurich.ibm.com/identity_mixer/) 是由 IBM 公司提出的一种身份认证技术，其工作方式与 PKI 体系类似，都是由离线的证书发布机构为用户颁发证书，再由用户持有该证书向服务提供者证明其具备访问权限。与 PKI 体系不同的是，Identity Mixer 具备以下两点特征：
- 假名机制：用户可以根据同一个私钥生成多个不同的公钥（称为假名），然后在不同的认证场景中使用不同的假名，避免服务提供方将多次认证行为联系起来；
- 证书灵活：用户可以将从证书发布机构获得的证书转换为跟假名绑定的有效令牌，该令牌包括的属性可以使证书中所有属性的任意子集，且可以使用证书发布机构的公钥验证其真伪。

Identity Mixer 的以上两点特性分别保证了多次认证行为的不可链接性和揭示属性的最小化，因此该技术非常适合在区块链这样开放透明的环境下使用。

Identity Mixer 依赖于 [Camenisch-Lysyanskaya（CL）签名方案](https://groups.csail.mit.edu/cis/pubs/lysyanskaya/cl02b.pdf )。相比于经典的签名方案（如 RSA，DSA 等），CL 签名的特点支持高效的零知识证明协议。该协议允许签名持有人向他人存在一个在公钥 $pk$ 下合法的消息签名对，其中消息中包含某些公开的属性；同时，不泄漏消息签名对除此以外的任何信息。在 Identity Mixer 方案中，证书是发行者对用户的密钥和属性值的 CL 签名。为了将凭证转换为可验证的令牌，用户生成零知识证明，表明他持有一个 $pk$ 下合法的消息签名对，其中消息包括其公开的属性值，并且所包含的密钥是假名对应的私钥。

Identity Mixer 系统也支持对认证过程的监管。为创建可监管的令牌，用户在监管者的公钥下加密标识凭证属性，以便只有监管者才能解密它。具体的，Identity Mixer 使用可验证的加密，允许用户证明加密的属性值与其所持凭证中的相同，而不会泄露该值。监管者可以检查此证明，从而确信如果他需要检查令牌，可发现正确的用户。

**Identity Mixer 在区块链中的应用**

著名的联盟链项目 [Hyperledger]( https://hyperledger-fabric.readthedocs.io/en/release-1.2/idemix.html ) 中采用的 Identity Mixer 技术可以在提供身份认证功能的同时将参与各方可获知的用户信息最小化。

## 四、区块链中用到的其他密码学技术

<table> 
  区块链中用到的其他密码学技术
 <tr>  <th colspan="2">名称</th><th>主要特点</th><th>数学依赖/构造方法</th><th>应用项目/研究论文</th></tr>
 <tr><td colspan="2">变色龙哈希函数</td> <td>带陷门的哈希函数 </td> <td>  
     <a href=" https://en.wikipedia.org/wiki/Claw-free_permutation">claw-free 陷门置换</a></td><td>
     <a href="https://eprint.iacr.org/2016/757.pdf">Redactable blockchain</a></td></tr> 
 <tr><td rowspan="2">一些特殊的签名方案</td><td>Sibling 签名</td><td>允许某个拥有一对公私钥对的签名者可以使用两个不同的签名算法进行签名</td><td>structure-preserving 签名方案</td><td><a href="https://acmccs.github.io/papers/p683-camenischA.pdf">Practical UC-Secure Delegatable Credentials with Attributes and Their Application to Blockchain</a></td></tr>    <tr>                        <td>FPS 签名</td><td>支持快速快速签名和验证</td><td>Bos-Chaum 签名方案</td><td><a href="https://ieeexplore.ieee.org/document/6956582">Permacoin</a></td></tr> 
  <tr><td colspan="2">先应式秘密分享</td><td>通过周期性地刷新每个参与者新碎片的值秘密分享的增加安全性</td><td>有限域内的随机多项式</td><td>
      <a href="https://eprint.iacr.org/2019/017">CHURP</a></td></tr> 
  <tr><td colspan="2">不经意传输</td><td>能使通信双方以一种选择模糊化的方式传送消息</td><td>RSA 大数分解问题或离散对数问题</td><td>
      <a href="https://eprint.iacr.org/2018/1050.pdf">APDB</a>、
      <a href="https://www.sciencedirect.com/science/article/pii/S0167739X17318630">Searchain</a> 等</td></tr> 
  <tr><td colspan="2">不经意随机访问机</td><td>基于硬件的加密方式，可以对不可信的存储服务器隐藏访问内存的模式</td><td>DDH 困难问题、杂凑函数</td><td>
      <a href="https://dl.acm.org/citation.cfm?doid=3133956.3134010">Solidus</a></td></tr> 
  <tr><td colspan="2">抗量子密码学</td><td>能抗量子计算机的攻击</td><td>格基困难问题、椭圆曲线同源映射问题、一般线性码译码问题、多变量密码</td><td>
      <a href="https://h.cash/">Hcash</a>、
      <a href="https://neo.org/">NEO</a>、
      <a href="https://eprint.iacr.org/2018/658.pdf">BPQS</a> 等</td></tr> 
</table>

### 4.1 变色龙哈希函数

[变色龙哈希](https://pdfs.semanticscholar.org/1c29/4428c76ba7d1d0bb5e1d1bc931138c092453.pdf) 的概念是由 Krawczyk 和 Rabin 在变色龙承诺的概念的基础上提出的，并给出了基于 [claw-free 陷门置换]( https://en.wikipedia.org/wiki/Claw-free_permutation)的变色龙哈希函数的构造 。变色龙哈希是指包含陷阱门的密码哈希函数，在不知道陷门的情况下很难找到哈希碰撞，但是知道陷门信息可以有效构成哈希碰撞。这虽然破坏了哈希函数的基本属性，但对于不知道陷门的使用者，这个哈希函数仍然可认为是安全的。

在 2017 的 EuroS&P 会议上由 Ateniese 等人利用变色龙哈希的特点，设计了可编辑区块链（ [Redactable blockchain]( https://eprint.iacr.org/2016/757.pdf ) ）。可编辑区块链虽然一定程度上破坏了区块链的不可更改、不可撤销的特性，但是从另一方面看也是扩大了区块链的应用场景，可满足政府的可监管需求，允许政府的介入式监管，也可满足金融银行等的一些业务需求。

在 Ateniese 等人提出可编辑区块链后，2019 年的 S&P 会议上又有研究者不利用变色龙哈希，而是通过投票协议的方式设计了一种可应用于比特币等公链系统的可编辑区块链协议 [Redactable Blockchain in the Permissionless Setting]( https://eprint.iacr.org/2016/757.pdf )；在2019 年的 NDSS 会议上， Derler 等人提出了基于策略的变色龙哈希（policy-based chameleon-hashes ， [PCH](  https://www.ndss-symposium.org/wp-content/uploads/2019/02/ndss2019_02A-3_Derler_paper.pdf  ) )，允许满足一定条件的参与者即可知晓对应哈希函数的碰撞，Derler 等人给出了 PCH 一般形式的构造并将其应用在区块链的设计中。

### 4.2 一些特殊的签名方案

#### 4.2.1 Sibling 签名

在 2017 年的 ACM CCS 会议中，来自苏黎世联邦理工的研究者提出一种 UC 安全的基于属性的实用可授权凭证设计（[Practical UC-Secure Delegatable Credentials with Attributes]( [http://delivery.acm.org/10.1145/3140000/3134025/p683-camenisch.pdf?ip=211.71.12.169&id=3134025&acc=ACTIVE%20SERVICE&key=BF85BBA5741FDC6E%2E478E8F2EC4A762F8%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35&__acm__=1572506789_e06c44715836712921947513f40810e5](http://delivery.acm.org/10.1145/3140000/3134025/p683-camenisch.pdf?ip=211.71.12.169&id=3134025&acc=ACTIVE SERVICE&key=BF85BBA5741FDC6E.478E8F2EC4A762F8.4D4702B0C3E38B35.4D4702B0C3E38B35&__acm__=1572506789_e06c44715836712921947513f40810e5) )），并基于区块链对其进行实现。其设计中用到的关键技术是一种基于双线性映射的签名方案（称为 Sibling 签名）。Sibling 签名的构造思想来源于 2015 年亚密会上 Groth 等人的 [structure-preserving 签名方案](https://doi.org/10.1007/978-3-662-48797-6_11)。Sibling 签名的主要特点是允许某个拥有一对公私钥对的签名者可以使用两个不同的签名算法进行签名，且这两个签名算法都有唯一对应的验证算法。Sibling 方案具体的设计细节可参考论文（[Practical UC-Secure Delegatable Credentials with Attributes and Their Application to Blockchain]( [http://delivery.acm.org/10.1145/3140000/3134025/p683-camenisch.pdf?ip=211.71.12.169&id=3134025&acc=ACTIVE%20SERVICE&key=BF85BBA5741FDC6E%2E478E8F2EC4A762F8%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35&__acm__=1572506789_e06c44715836712921947513f40810e5](http://delivery.acm.org/10.1145/3140000/3134025/p683-camenisch.pdf?ip=211.71.12.169&id=3134025&acc=ACTIVE SERVICE&key=BF85BBA5741FDC6E.478E8F2EC4A762F8.4D4702B0C3E38B35.4D4702B0C3E38B35&__acm__=1572506789_e06c44715836712921947513f40810e5) )）。

#### 4.2.2 FPS 签名

在 [Permacoin](http://soc1024.ece.illinois.edu/permacoin.pdf) 项目中，为了解决基于 RSA 的签名算法消耗较高的算力的问题，研究者采用了一种基于哈希签名方案的签名（称为 floating preimage signature，FPS）。其构造的思想来源于 [Bos-Chaum 签名方案]( https://link.springer.com/chapter/10.1007/3-540-48071-4_1 )，主要设计方法来源于 2002 年的文章 [Better than BiBa Short One-time Signatures with Fast Signing and Verifying ]( https://www.cs.bu.edu/~reyzin/papers/one-time-sigs.pdf )，这种方案支持快速快速签名和验证。简单的理解，在 FPS 方案中，私钥是随机字符串构成的集合 $S$，公钥是以这些字符串构成的 Merkle 树根对应的哈希值；当需要对某个消息 $m$ 进行签名时，随时的从 $S$ 中选取某一个字符串 $m$ 进行签名。FPS 方案具体的设计细节可参考 [Permacoin](http://soc1024.ece.illinois.edu/permacoin.pdf) 论文。

### 4.3 先应式秘密分享

[先应式秘密分享技术（Proactive secret sharing，PSS）](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.40.8922&rep=rep1&type=pdf) 最初由 Herzberg 等人在 1995 年的美密会上提出，其主要思想是：将时间分成一个个的周期，在$(k,n)-$门限密钥共享的基础上，通过周期性地刷新每个参与者新碎片的值（但不改变共享的密钥）并清除原来的碎片值，是的攻击者在 在一个周期中获得的信息在刷新之后变得毫无用处。所以，攻击者要想窃取一个系统的密钥，必须在同一个周期内攻破 $k$ 个以上的参与者才可能成功。

Herzberg 等人给出的 PSS 协议主要依赖有限域内的随机多项式进行构造，但效率并不高；Brendel 对其方案进行改进，给出了一种高效的 PSS 构造方案 [EPSS]( https://eprint.iacr.org/2017/719.pdf)；但目前传统的 PSS 协议大多都不支持参与者成员的动态更新（即允许参与者中途退出秘密分享），2019 年的 ACM CCS 会议上，有研究者提出了一种基于公链的、支持成员动态更新的高效 PSS 协议 [CHURP]( https://eprint.iacr.org/2019/017)，可进一步用在需要秘密分享技术的区块链项目中。

### 4.4 不经意传输

不经意传输协议（Oblivious Transfer ，OT）在 1981 年由 [Robin](https://eprint.iacr.org/2005/187.pdf ) 提出，是一种可保护隐私的两方通信协议，能使通信双方以一种选择模糊化的方式传送消息。不经意传输协议可用于构造安全多方计算协议。可以这样简单的理解 OT 协议：以 1/2-OT 协议为例，假设 S 有一个秘密，想以$\frac{1}{2}$的概率传递给 R，即 R 有 $\frac{1}{2}$ 的概率收到这个秘密，另外有 $\frac{1}{2}$ 的概率收不到；协议运行结束后，R 知道自己是否收到了这个秘密，但 S 却不知道 R 是否收到了这个秘密。

可通过基于 RSA 大数分解问题或者基于离散对数问题构造不经意传输协议。例如可通过如下的方案构造 1/2-OT 协议：

设 S 想传递给 R 的秘密是整数 $n$（为两个大素数之积）的因数分解，两者运行如下协议：

1. R 随机选一个数 $x$，将 $x^2\mod n$ 发送给 S；
2. S 计算 $x^2\mod n$ 的四个平方根 $x,-x,y,-y$，并将其中一个发送给 R。注意 A 只知道 $x^2\mod n$ 但不知道 4 个平方根中哪一个是 R 选的 $x$ ；
3. R 检查收到的数是否与 $x$ 或 $-x$ 在模 $n$ 下同余，如果是，则 R 没有得到额外的新的信息；如果不是，则 R 就掌握了 $x^2\mod n$ 的两个不同的平方根，从而可以分解 $n$。注意此时 S 不知道是哪种情况。

以上协议基于这样一个事实：已知某数在模 $n$下两个不同的平方根，就可以分解 $n$。显然 R 有$\frac{1}{2}$的概率得到 $n$的分解。

在区块链中，OT 协议除了用于构造安全多方计算外，OT 协议还可用于设计高级的智能合约（例如 [APDB]( https://eprint.iacr.org/2018/1050.pdf )）和增强隐私保护（例如 [Searchain](https://www.sciencedirect.com/science/article/pii/S0167739X17318630)）等。

### 4.5 不经意随机访问机

[不经意随机访问机（Oblivious RAM，ORAM）](https://web.cs.ucla.edu/~rafail/PUBLIC/09.pdf)，最开始是由 Goldreich 和 Ostrovsky 在 1992 年为实现软件保护提出来的。 ORAM 是一种基于硬件的加密方式，可以对不可信的存储服务器隐藏访问内存的模式。简单的讲，ORAM 指的是处理器访问内存的操作序列和地址序列，ORAM 保证了在存储器中的任意数据块不会永久驻留在某一个物理地址中， 这确保了任意两次访问不会产生关联。同时，ORAM 将每一次读写访问细化成一次读取加一次写回的原子操作， 其中读访问转化成读取内容再写回相同内容，写访问转化成读取内容再写回更新后的内容，使得攻击者不能够区分具体的访问方式。

这种硬件级别的安全访问控制设计较难用在一般的区块链系统设计中，但在 2017 年的 ACM CCS 会议上，来自 [IC3](https://www.initc3.org/ ) 实验室的研究者提出了一种可公开验证的不经意随机访问机（Publicly Verifiable Oblivious RAM Machine），并基于此构造了在公链网络环境下可以保证交易隐私的协议 [Solidus](https://dl.acm.org/citation.cfm?doid=3133956.3134010)。

### 4.6 抗量子密码学

目前区块链系统中应用的密码学技术绝大多数不能抗量子敌手的攻击。量子计算技术发展迅速，使得大部分密码学算法或协议能被轻易攻破，因此需要未雨绸缪研究抗量子计算攻击的密码方案并将其应用在区块链的设计中。可以通过格基困难问题、椭圆曲线同源映射问题、一般线性码译码问题、多变量密码进行抗量子密码构造。目前已有一些区块链系统以使用抗量子的签名算法作为系统的核心特色，例如：

- [Hcash](https://h.cash/) 项目在数字货币系统中实现了著名的抗量子签名算法 [BLISS]( https://eprint.iacr.org/2013/383.pdf) 来取代 ECDSA 算法；
- [NEO]( https://neo.org/ ) 项目称其开发了新型抗量子签名算法 NeoQS 来实现抗量子安全性，但所使用的 NeoQS 签名方案没有正式的学术论文发表；
- 有研究者提出适用于区块链的抗量子算法 [BPQS](https://eprint.iacr.org/2018/658.pdf) 和 [基于格基困难问题的抗量子区块链设计]( https://ieeexplore.ieee.org/document/8340794 )，但由于抗量子算法设计和实现需要比较严格的理论和实际检验，目前已有的抗量子区块链系统设计还需要更进一步的研究。